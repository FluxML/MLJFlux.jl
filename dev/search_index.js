var documenterSearchIndex = {"docs":
[{"location":"contributing/#Adding-new-models-to-MLJFlux","page":"Contributing","title":"Adding new models to MLJFlux","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This section assumes familiarity with the MLJ model API","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If one subtypes a new model type as either MLJFlux.MLJFluxProbabilistic or MLJFlux.MLJFluxDeterministic, then instead of defining new methods for MLJModelInterface.fit and MLJModelInterface.update one can make use of fallbacks by implementing the lower level methods shape, build, and fitresult. See the classifier source code for an example.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"One still needs to implement a new predict method.","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"EditURL = \"incremental.jl\"","category":"page"},{"location":"workflow examples/Incremental Training/incremental/#Incremental-Training-with-MLJFlux","page":"Incremental Training","title":"Incremental Training with MLJFlux","text":"","category":"section"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"In this workflow example we explore how to incrementally train MLJFlux models.","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"workflow examples/Incremental Training/incremental/#Basic-Imports","page":"Incremental Training","title":"Basic Imports","text":"","category":"section"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source","category":"page"},{"location":"workflow examples/Incremental Training/incremental/#Loading-and-Splitting-the-Data","page":"Incremental Training","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng=123);\nX = Float32.(X)      # To be compatible with type of network network parameters\n(X_train, X_test), (y_train, y_test) = partition((X, y), 0.8,\n                                                 multi = true,\n                                                 shuffle = true,\n                                                 rng=42);\nnothing #hide","category":"page"},{"location":"workflow examples/Incremental Training/incremental/#Instantiating-the-model","page":"Incremental Training","title":"Instantiating the model","text":"","category":"section"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"Now let's construct our model. This follows a similar setup to the one followed in the Quick Start.","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Flux.ADAM(0.01),\n    batch_size=8,\n    epochs=10,\n    rng=42\n    )","category":"page"},{"location":"workflow examples/Incremental Training/incremental/#Initial-round-of-training","page":"Incremental Training","title":"Initial round of training","text":"","category":"section"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"Now let's train the model. Calling fit! will automatically train it for 100 epochs as specified above.","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"mach = machine(clf, X_train, y_train)\nfit!(mach)","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"Let's evaluate the training loss and validation accuracy","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"training_loss = cross_entropy(predict(mach, X_train), y_train)","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"val_acc = accuracy(predict_mode(mach, X_test), y_test)","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"Poor performance it seems.","category":"page"},{"location":"workflow examples/Incremental Training/incremental/#Incremental-Training","page":"Incremental Training","title":"Incremental Training","text":"","category":"section"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"Now let's train it for another 30 epochs at half the original learning rate. All we need to do is changes these hyperparameters and call fit again. It won't reset the model parameters before training.","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"clf.optimiser.eta = clf.optimiser.eta / 2\nclf.epochs = clf.epochs + 30\nfit!(mach, verbosity=2);\nnothing #hide","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"Let's evaluate the training loss and validation accuracy","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"training_loss = cross_entropy(predict(mach, X_train), y_train)","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"training_acc = accuracy(predict_mode(mach, X_test), y_test)","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"That's much better. If we are rather interested in resetting the model parameters before fitting, we can do fit(mach, force=true).","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"","category":"page"},{"location":"workflow examples/Incremental Training/incremental/","page":"Incremental Training","title":"Incremental Training","text":"This page was generated using Literate.jl.","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"EditURL = \"tuning.jl\"","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/#Neural-Architecture-Search-with-MLJFlux","page":"Neural Architecture Search","title":"Neural Architecture Search with MLJFlux","text":"","category":"section"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Neural Architecture Search is (NAS) is an instance of hyperparameter tuning concerned with tuning model hyperparameters defining the architecture itself. Although it's typically performed with sophisticated search algorithms for efficiency, in this example we will be using a simple random search.","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/#Basic-Imports","page":"Neural Architecture Search","title":"Basic Imports","text":"","category":"section"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nusing RDatasets: RDatasets        # Dataset source\nusing DataFrames        # To view tuning results in a table","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/#Loading-and-Splitting-the-Data","page":"Neural Architecture Search","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng = 123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nfirst(X, 5)","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/#Instantiating-the-model","page":"Neural Architecture Search","title":"Instantiating the model","text":"","category":"section"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Now let's construct our model. This follows a similar setup the one followed in the Quick Start.","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg = \"MLJFlux\"\nclf = NeuralNetworkClassifier(\n\tbuilder = MLJFlux.MLP(; hidden = (1, 1, 1), σ = Flux.relu),\n\toptimiser = Flux.ADAM(0.01),\n\tbatch_size = 8,\n\tepochs = 10,\n\trng = 42,\n)","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/#Generating-Network-Architectures","page":"Neural Architecture Search","title":"Generating Network Architectures","text":"","category":"section"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"We know that the MLP builder takes a tuple of the form (z_1 z_2  z_k) to define a network with k hidden layers and where the ith layer has z_i neurons. We will proceed by defining a function that can generate all possible networks with a specific number of hidden layers, a minimum and maximum number of neurons per layer and increments to consider for the number of neurons.","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"function generate_networks(;\n\tmin_neurons::Int,\n\tmax_neurons::Int,\n\tneuron_step::Int,\n\tnum_layers::Int,\n)\n\t# Define the range of neurons\n\tneuron_range = min_neurons:neuron_step:max_neurons\n\n\t# Empty list to store the network configurations\n\tnetworks = Vector{Tuple{Vararg{Int, num_layers}}}()\n\n\t# Recursive helper function to generate all combinations of tuples\n\tfunction generate_tuple(current_layers, remaining_layers)\n\t\tif remaining_layers > 0\n\t\t\tfor n in neuron_range\n\t\t\t\t# current_layers =[] then current_layers=[(min_neurons)],\n\t\t\t\t# [(min_neurons+neuron_step)], [(min_neurons+2*neuron_step)],...\n\t\t\t\t# for each of these we call generate_layers again which appends\n\t\t\t\t# the n combinations for each one of them\n\t\t\t\tgenerate_tuple(vcat(current_layers, [n]), remaining_layers - 1)\n\t\t\tend\n\t\telse\n\t\t\t# in the base case, no more layers to \"recurse on\"\n\t\t\t# and we just append the current_layers as a tuple\n\t\t\tpush!(networks, tuple(current_layers...))\n\t\tend\n\tend\n\n\t# Generate networks for the given number of layers\n\tgenerate_tuple([], num_layers)\n\n\treturn networks\nend","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Now let's generate an array of all possible neural networks with three hidden layers and number of neurons per layer ∈ [1,64] with a step of 4","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"networks_space =\n\tgenerate_networks(min_neurons = 1, max_neurons = 64, neuron_step = 4, num_layers = 3)\n\nnetworks_space[1:5]","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/#Wrapping-the-Model-for-Tuning","page":"Neural Architecture Search","title":"Wrapping the Model for Tuning","text":"","category":"section"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Let's use this array to define the range of hyperparameters and pass it along with the model to the TunedModel constructor.","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"r1 = range(clf, :(builder.hidden), values = networks_space)\n\ntuned_clf = TunedModel(\n\tmodel = clf,\n\ttuning = RandomSearch(),\n\tresampling = CV(nfolds = 4, rng = 42),\n\trange = [r1],\n\tmeasure = cross_entropy,\n\tn = 100,             # searching over 100 random samples are enough\n);\nnothing #hide","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/#Performing-the-Search","page":"Neural Architecture Search","title":"Performing the Search","text":"","category":"section"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Similar to the last workflow example, all we need now is to fit our model and the search will take place automatically:","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"mach = machine(tuned_clf, X, y);\nfit!(mach, verbosity = 0);\nfitted_params(mach).best_model","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/#Analyzing-the-Search-Results","page":"Neural Architecture Search","title":"Analyzing the Search Results","text":"","category":"section"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Let's analyze the search results by converting the history array to a dataframe and viewing it:","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"history = report(mach).history\nhistory_df = DataFrame(\n\tmlp = [x[:model].builder for x in history],\n\tmeasurement = [x[:measurement][1] for x in history],\n)\nfirst(sort!(history_df, [order(:measurement)]), 10)","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"","category":"page"},{"location":"workflow examples/Basic Neural Architecture Search/tuning/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/Multitarget Regression/","page":"Multi-Target Regression","title":"Multi-Target Regression","text":"MLJFlux.MultitargetNeuralNetworkRegressor","category":"page"},{"location":"interface/Multitarget Regression/#MLJFlux.MultitargetNeuralNetworkRegressor","page":"Multi-Target Regression","title":"MLJFlux.MultitargetNeuralNetworkRegressor","text":"MultitargetNeuralNetworkRegressor\n\nA model type for constructing a multitarget neural network regressor, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nMultitargetNeuralNetworkRegressor = @load MultitargetNeuralNetworkRegressor pkg=MLJFlux\n\nDo model = MultitargetNeuralNetworkRegressor() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in MultitargetNeuralNetworkRegressor(builder=...).\n\nMultitargetNeuralNetworkRegressor is for training a data-dependent Flux.jl neural network to predict a multi-valued Continuous target, represented as a table, given a table of Continuous features. Users provide a recipe for constructing the network, based on properties of the data that is encountered, by specifying an appropriate builder. See MLJFlux documentation for more on builders.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX is either a Matrix or any table of input features (eg, a DataFrame) whose columns are of scitype Continuous; check column scitypes with schema(X). If X is a Matrix, it is assumed to have columns corresponding to features and rows corresponding to observations.\ny is the target, which can be any table or matrix of output targets whose element scitype is Continuous; check column scitypes with schema(y). If y is a Matrix, it is assumed to have columns corresponding to variables and rows corresponding to observations.\n\nHyper-parameters\n\nbuilder=MLJFlux.Linear(σ=Flux.relu): An MLJFlux builder that constructs a neural network. Possible builders include: Linear, Short, and MLP. See MLJFlux documentation for more on builders, and the example below for using the @builder convenience macro.\noptimiser::Optimisers.Adam(): An Optimisers.jl optimiser. The optimiser performs the updating of the weights of the network. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.mse: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a regression task, natural loss functions are:\nFlux.mse\nFlux.mae\nFlux.msle\nFlux.huber_loss\nCurrently MLJ measures are not supported as loss functions here.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights. Typically, batch size is between 8 and\nIncreassing batch size may accelerate training if acceleration=CUDALibs() and a\nGPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞). Note the history reports unpenalized losses.\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training. The default is Random.default_rng().\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew having the same scitype as X above. Predictions are deterministic.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers,  functions, and activations  which make up the neural network.\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalised if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we apply a multi-target regression model to synthetic data:\n\nusing MLJ\nimport MLJFlux\nusing Flux\n\nFirst, we generate some synthetic data (needs MLJBase 0.20.16 or higher):\n\nX, y = make_regression(100, 9; n_targets = 2) # both tables\nschema(y)\nschema(X)\n\nSplitting off a test set:\n\n(X, Xtest), (y, ytest) = partition((X, y), 0.7, multi=true);\n\nNext, we can define a builder, making use of a convenience macro to do so.  In the following @builder call, n_in is a proxy for the number input features and n_out the number of target variables (both known at fit! time), while rng is a proxy for a RNG (which will be passed from the rng field of model defined below).\n\nbuilder = MLJFlux.@builder begin\n    init=Flux.glorot_uniform(rng)\n    Chain(\n        Dense(n_in, 64, relu, init=init),\n        Dense(64, 32, relu, init=init),\n        Dense(32, n_out, init=init),\n    )\nend\n\nInstantiating the regression model:\n\nMultitargetNeuralNetworkRegressor = @load MultitargetNeuralNetworkRegressor\nmodel = MultitargetNeuralNetworkRegressor(builder=builder, rng=123, epochs=20)\n\nWe will arrange for standardization of the the target by wrapping our model in  TransformedTargetModel, and standardization of the features by inserting the wrapped  model in a pipeline:\n\npipe = Standardizer |> TransformedTargetModel(model, target=Standardizer)\n\nIf we fit with a high verbosity (>1), we will see the losses during training. We can also see the losses in the output of report(mach)\n\nmach = machine(pipe, X, y)\nfit!(mach, verbosity=2)\n\n# first element initial loss, 2:end per epoch training losses\nreport(mach).transformed_target_model_deterministic.model.training_losses\n\nFor experimenting with learning rate, see the NeuralNetworkRegressor example.\n\npipe.transformed_target_model_deterministic.model.optimiser.eta = 0.0001\n\nWith the learning rate fixed, we can now compute a CV estimate of the performance (using all data bound to mach) and compare this with performance on the test set:\n\n# custom MLJ loss:\nmulti_loss(yhat, y) = l2(MLJ.matrix(yhat), MLJ.matrix(y)) |> mean\n\n# CV estimate, based on `(X, y)`:\nevaluate!(mach, resampling=CV(nfolds=5), measure=multi_loss)\n\n# loss for `(Xtest, test)`:\nfit!(mach) # trains on all data `(X, y)`\nyhat = predict(mach, Xtest)\nmulti_loss(yhat, ytest)\n\nSee also NeuralNetworkRegressor\n\n\n\n\n\n","category":"type"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"EditURL = \"live-training.jl\"","category":"page"},{"location":"workflow examples/Live Training/live-training/#Incremental-Training-with-MLJFlux","page":"Live Training","title":"Incremental Training with MLJFlux","text":"","category":"section"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"workflow examples/Live Training/live-training/#Basic-Imports","page":"Live Training","title":"Basic Imports","text":"","category":"section"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nusing Plots             # For training plot","category":"page"},{"location":"workflow examples/Live Training/live-training/#Loading-and-Splitting-the-Data","page":"Live Training","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng=123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nnothing #hide","category":"page"},{"location":"workflow examples/Live Training/live-training/#Instantiating-the-model","page":"Live Training","title":"Instantiating the model","text":"","category":"section"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"Now let's construct our model. This follows a similar setup to the one followed in the Quick Start.","category":"page"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Flux.ADAM(0.01),\n    batch_size=8,\n    epochs=50,\n    rng=42\n    )","category":"page"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"Now let's wrap this in an iterated model. We will use a callback that makes a plot for validation losses each iteration.","category":"page"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"stop_conditions = [\n    Step(1),            # Repeatedly train for one iteration\n    NumberLimit(100),   # Don't train for more than 100 iterations\n]\n\nvalidation_losses =  []\ngr(reuse=true)                  # use the same window for plots\nfunction plot_loss(loss)\n    push!(validation_losses, loss)\n    display(plot(validation_losses, label=\"validation loss\", xlim=(1, 100)))\n   sleep(.01)                   # to catch up with the plots while they are being generated\nend\n\ncallbacks = [ WithLossDo(plot_loss),]\n\niterated_model = IteratedModel(model=clf,\n                               resampling=Holdout(),    # Split the data internally into 0.7 training and 0.3 validation\n                               measures=log_loss,\n                               iteration_parameter=:(epochs),\n                               controls=vcat(stop_conditions, callbacks),\n                               retrain=true                  # no need to retrain on all data at the end\n                               )","category":"page"},{"location":"workflow examples/Live Training/live-training/#Live-Training","page":"Live Training","title":"Live Training","text":"","category":"section"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"Simply fitting the model is all we need","category":"page"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"mach = machine(iterated_model, X, y)\nfit!(mach, force=true)","category":"page"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"using Literate #src","category":"page"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"","category":"page"},{"location":"workflow examples/Live Training/live-training/","page":"Live Training","title":"Live Training","text":"This page was generated using Literate.jl.","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"EditURL = \"comparison.jl\"","category":"page"},{"location":"workflow examples/Comparison/comparison/#Model-Comparison-with-MLJFlux","page":"Model Comparison","title":"Model Comparison with MLJFlux","text":"","category":"section"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"In this workflow example, we see how we can compare different machine learning models with a neural network from MLJFlux.","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"workflow examples/Comparison/comparison/#Basic-Imports","page":"Model Comparison","title":"Basic Imports","text":"","category":"section"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nusing DataFrames        # To visualize hyperparameter search results","category":"page"},{"location":"workflow examples/Comparison/comparison/#Loading-and-Splitting-the-Data","page":"Model Comparison","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng=123);","category":"page"},{"location":"workflow examples/Comparison/comparison/#Instantiating-the-models","page":"Model Comparison","title":"Instantiating the models","text":"","category":"section"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"Now let's construct our model. This follows a similar setup to the one followed in the Quick Start.","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n\nclf1 = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Flux.ADAM(0.01),\n    batch_size=8,\n    epochs=50,\n    rng=42\n    )","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"NeuralNetworkClassifier(\n  builder = MLP(\n        hidden = (5, 4), \n        σ = NNlib.relu), \n  finaliser = NNlib.softmax, \n  optimiser = Adam(0.01, (0.9, 0.999), 1.0e-8, IdDict{Any, Any}()), \n  loss = Flux.Losses.crossentropy, \n  epochs = 50, \n  batch_size = 8, \n  lambda = 0.0, \n  alpha = 0.0, \n  rng = 42, \n  optimiser_changes_trigger_retraining = false, \n  acceleration = CPU1{Nothing}(nothing))","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"Let's as well load and construct three other classical machine learning models:","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"BayesianLDA = @load BayesianLDA pkg=MultivariateStats\nclf2 = BayesianLDA()\nRandomForestClassifier = @load RandomForestClassifier pkg=DecisionTree\nclf3 = RandomForestClassifier()\nXGBoostClassifier = @load XGBoostClassifier pkg=XGBoost\nclf4 = XGBoostClassifier();","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"[ Info: For silent loading, specify `verbosity=0`. \nimport MLJMultivariateStatsInterface ✔\n[ Info: For silent loading, specify `verbosity=0`. \nimport MLJDecisionTreeInterface ✔\n[ Info: For silent loading, specify `verbosity=0`. \nimport MLJXGBoostInterface ✔\n","category":"page"},{"location":"workflow examples/Comparison/comparison/#Wrapping-One-of-the-Models-in-a-TunedModel","page":"Model Comparison","title":"Wrapping One of the Models in a TunedModel","text":"","category":"section"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"Instead of just comparing with four models with the default/given hyperparameters, we will give XGBoostClassifier an unfair advantage By wrapping it in a TunedModel that considers the best learning rate η for the model.","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"r1 = range(clf4, :eta, lower=0.01, upper=0.5, scale=:log10)\ntuned_model_xg = TunedModel(\n    model=clf4,\n    ranges=[r1],\n    tuning=Grid(resolution=10),\n    resampling=CV(nfolds=5, rng=42),\n    measure=cross_entropy,\n);","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"Of course, one can wrap each of the four in a TunedModel if they are interested in comparing the models over a large set of their hyperparameters.","category":"page"},{"location":"workflow examples/Comparison/comparison/#Comparing-the-models","page":"Model Comparison","title":"Comparing the models","text":"","category":"section"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"We simply pass the four models to the models argument of the TunedModel construct","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"tuned_model = TunedModel(\n    models=[clf1, clf2, clf3, tuned_model_xg],\n    tuning=Explicit(),\n    resampling=CV(nfolds=5, rng=42),\n    measure=cross_entropy,\n);","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"Then wrapping our tuned model in a machine and fitting it.","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"mach = machine(tuned_model, X, y);\nfit!(mach, verbosity=0);","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"┌ Warning: Layer with Float32 parameters got Float64 input.\n│   The input will be converted, but any earlier layers may be very slow.\n│   layer = Dense(4 => 5, relu)  # 25 parameters\n│   summary(x) = \"4×8 Matrix{Float64}\"\n└ @ Flux ~/.julia/packages/Flux/Wz6D4/src/layers/stateless.jl:60\n","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"Now let's see the history for more details on the performance for each of the models","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"history = report(mach).history\nhistory_df = DataFrame(mlp = [x[:model] for x in history], measurement = [x[:measurement][1] for x in history])\nsort!(history_df, [order(:measurement)])","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"<div><div style = \"float: left;\"><span>4×2 DataFrame</span></div><div style = \"clear: both;\"></div></div><div class = \"data-frame\" style = \"overflow-x: scroll;\"><table class = \"data-frame\" style = \"margin-bottom: 6px;\"><thead><tr class = \"header\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">Row</th><th style = \"text-align: left;\">mlp</th><th style = \"text-align: left;\">measurement</th></tr><tr class = \"subheader headerLastRow\"><th class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\"></th><th title = \"Probabilistic\" style = \"text-align: left;\">Probabil…</th><th title = \"Float64\" style = \"text-align: left;\">Float64</th></tr></thead><tbody><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">1</td><td style = \"text-align: left;\">BayesianLDA(method = gevd, …)</td><td style = \"text-align: right;\">0.0610826</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">2</td><td style = \"text-align: left;\">RandomForestClassifier(max_depth = -1, …)</td><td style = \"text-align: right;\">0.106565</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">3</td><td style = \"text-align: left;\">NeuralNetworkClassifier(builder = MLP(hidden = (5, 4), …), …)</td><td style = \"text-align: right;\">0.113266</td></tr><tr><td class = \"rowNumber\" style = \"font-weight: bold; text-align: right;\">4</td><td style = \"text-align: left;\">ProbabilisticTunedModel(model = XGBoostClassifier(test = 1, …), …)</td><td style = \"text-align: right;\">0.221056</td></tr></tbody></table></div>","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"This is Occam's razor in practice.","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"","category":"page"},{"location":"workflow examples/Comparison/comparison/","page":"Model Comparison","title":"Model Comparison","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/Regression/","page":"Regression","title":"Regression","text":"MLJFlux.NeuralNetworkRegressor","category":"page"},{"location":"interface/Regression/#MLJFlux.NeuralNetworkRegressor","page":"Regression","title":"MLJFlux.NeuralNetworkRegressor","text":"NeuralNetworkRegressor\n\nA model type for constructing a neural network regressor, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nNeuralNetworkRegressor = @load NeuralNetworkRegressor pkg=MLJFlux\n\nDo model = NeuralNetworkRegressor() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in NeuralNetworkRegressor(builder=...).\n\nNeuralNetworkRegressor is for training a data-dependent Flux.jl neural network to predict a Continuous target, given a table of Continuous features. Users provide a recipe for constructing the network, based on properties of the data that is encountered, by specifying an appropriate builder. See MLJFlux documentation for more on builders.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX is either a Matrix or any table of input features (eg, a DataFrame) whose columns are of scitype Continuous; check column scitypes with schema(X). If X is a Matrix, it is assumed to have columns corresponding to features and rows corresponding to observations.\ny is the target, which can be any AbstractVector whose element scitype is Continuous; check the scitype with scitype(y)\n\nTrain the machine with fit!(mach, rows=...).\n\nHyper-parameters\n\nbuilder=MLJFlux.Linear(σ=Flux.relu): An MLJFlux builder that constructs a neural  network. Possible builders include: MLJFlux.Linear, MLJFlux.Short, and  MLJFlux.MLP. See MLJFlux documentation for more on builders, and the example below  for using the @builder convenience macro.\noptimiser::Optimisers.Adam(): An Optimisers.jl optimiser. The optimiser performs the updating of the weights of the network. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.mse: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a regression task, natural loss functions are:\nFlux.mse\nFlux.mae\nFlux.msle\nFlux.huber_loss\nCurrently MLJ measures are not supported as loss functions here.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights. Typically, batch size is between 8 and\nIncreasing batch size may accelerate training if acceleration=CUDALibs() and a\nGPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞). Note the history reports unpenalized losses.\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training. The default is Random.default_rng().\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew, which should have the same scitype as X above.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers, functions,  and activations which make up the neural network.\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalized if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we build a regression model for the Boston house price dataset.\n\nusing MLJ\nimport MLJFlux\nusing Flux\n\nFirst, we load in the data: The :MEDV column becomes the target vector y, and all remaining columns go into a table X, with the exception of :CHAS:\n\ndata = OpenML.load(531); # Loads from https://www.openml.org/d/531\ny, X = unpack(data, ==(:MEDV), !=(:CHAS); rng=123);\n\nscitype(y)\nschema(X)\n\nSince MLJFlux models do not handle ordered factors, we'll treat :RAD as Continuous:\n\nX = coerce(X, :RAD=>Continuous)\n\nSplitting off a test set:\n\n(X, Xtest), (y, ytest) = partition((X, y), 0.7, multi=true);\n\nNext, we can define a builder, making use of a convenience macro to do so.  In the following @builder call, n_in is a proxy for the number input features (which will be known at fit! time) and rng is a proxy for a RNG (which will be passed from the rng field of model defined below). We also have the parameter n_out which is the number of output features. As we are doing single target regression, the value passed will always be 1, but the builder we define will also work for MultitargetNeuralRegressor.\n\nbuilder = MLJFlux.@builder begin\n    init=Flux.glorot_uniform(rng)\n    Chain(\n        Dense(n_in, 64, relu, init=init),\n        Dense(64, 32, relu, init=init),\n        Dense(32, n_out, init=init),\n    )\nend\n\nInstantiating a model:\n\nNeuralNetworkRegressor = @load NeuralNetworkRegressor pkg=MLJFlux\nmodel = NeuralNetworkRegressor(\n    builder=builder,\n    rng=123,\n    epochs=20\n)\n\nWe arrange for standardization of the the target by wrapping our model in TransformedTargetModel, and standardization of the features by inserting the wrapped model in a pipeline:\n\npipe = Standardizer |> TransformedTargetModel(model, target=Standardizer)\n\nIf we fit with a high verbosity (>1), we will see the losses during training. We can also see the losses in the output of report(mach).\n\nmach = machine(pipe, X, y)\nfit!(mach, verbosity=2)\n\n# first element initial loss, 2:end per epoch training losses\nreport(mach).transformed_target_model_deterministic.model.training_losses\n\nExperimenting with learning rate\n\nWe can visually compare how the learning rate affects the predictions:\n\nusing Plots\n\nrates = rates = [5e-5, 1e-4, 0.005, 0.001, 0.05]\nplt=plot()\n\nforeach(rates) do η\n  pipe.transformed_target_model_deterministic.model.optimiser.eta = η\n  fit!(mach, force=true, verbosity=0)\n  losses =\n      report(mach).transformed_target_model_deterministic.model.training_losses[3:end]\n  plot!(1:length(losses), losses, label=η)\nend\n\nplt\n\npipe.transformed_target_model_deterministic.model.optimiser.eta = 0.0001\n\nWith the learning rate fixed, we compute a CV estimate of the performance (using all data bound to mach) and compare this with performance on the test set:\n\n# CV estimate, based on `(X, y)`:\nevaluate!(mach, resampling=CV(nfolds=5), measure=l2)\n\n# loss for `(Xtest, test)`:\nfit!(mach) # train on `(X, y)`\nyhat = predict(mach, Xtest)\nl2(yhat, ytest)  |> mean\n\nThese losses, for the pipeline model, refer to the target on the original, unstandardized, scale.\n\nFor implementing stopping criterion and other iteration controls, refer to examples linked from the MLJFlux documentation.\n\nSee also MultitargetNeuralNetworkRegressor\n\n\n\n\n\n","category":"type"},{"location":"interface/Builders/","page":"Builders","title":"Builders","text":"MLJFlux.Linear","category":"page"},{"location":"interface/Builders/#MLJFlux.Linear","page":"Builders","title":"MLJFlux.Linear","text":"Linear(; σ=Flux.relu)\n\nMLJFlux builder that constructs a fully connected two layer network with activation function σ. The number of input and output nodes is determined from the data. Weights are initialized using Flux.glorot_uniform(rng), where rng is inferred from the rng field of the MLJFlux model.\n\n\n\n\n\n","category":"type"},{"location":"interface/Builders/","page":"Builders","title":"Builders","text":"MLJFlux.Short","category":"page"},{"location":"interface/Builders/#MLJFlux.Short","page":"Builders","title":"MLJFlux.Short","text":"Short(; n_hidden=0, dropout=0.5, σ=Flux.sigmoid)\n\nMLJFlux builder that constructs a full-connected three-layer network using n_hidden nodes in the hidden layer and the specified dropout (defaulting to 0.5). An activation function σ is applied between the hidden and final layers. If n_hidden=0 (the default) then n_hidden is the geometric mean of the number of input and output nodes.  The number of input and output nodes is determined from the data.\n\nEach layer is initialized using Flux.glorot_uniform(rng), where rng is inferred from the rng field of the MLJFlux model.\n\n\n\n\n\n","category":"type"},{"location":"interface/Builders/","page":"Builders","title":"Builders","text":"MLJFlux.MLP","category":"page"},{"location":"interface/Builders/#MLJFlux.MLP","page":"Builders","title":"MLJFlux.MLP","text":"MLP(; hidden=(100,), σ=Flux.relu)\n\nMLJFlux builder that constructs a Multi-layer perceptron network. The ith element of hidden represents the number of neurons in the ith hidden layer. An activation function σ is applied between each layer.\n\nEach layer is initialized using Flux.glorot_uniform(rng), where rng is inferred from the rng field of the MLJFlux model.\n\n\n\n\n\n","category":"type"},{"location":"interface/Builders/","page":"Builders","title":"Builders","text":"MLJFlux.@builder","category":"page"},{"location":"interface/Builders/#MLJFlux.@builder","page":"Builders","title":"MLJFlux.@builder","text":"@builder neural_net\n\nCreates a builder for neural_net. The variables rng, n_in, n_out and n_channels can be used to create builders for any random number generator rng, input and output sizes n_in and n_out and number of input channels n_channels.\n\nExamples\n\njulia> import MLJFlux: @builder;\n\njulia> nn = NeuralNetworkRegressor(builder = @builder(Chain(Dense(n_in, 64, relu),\n                                                            Dense(64, 32, relu),\n                                                            Dense(32, n_out))));\n\njulia> conv_builder = @builder begin\n           front = Chain(Conv((3, 3), n_channels => 16), Flux.flatten)\n           d = Flux.outputsize(front, (n_in..., n_channels, 1)) |> first\n           Chain(front, Dense(d, n_out));\n       end\n\njulia> conv_nn = NeuralNetworkRegressor(builder = conv_builder);\n\n\n\n\n\n","category":"macro"},{"location":"interface/Image Classification/","page":"Image Classification","title":"Image Classification","text":"MLJFlux.ImageClassifier","category":"page"},{"location":"interface/Image Classification/#MLJFlux.ImageClassifier","page":"Image Classification","title":"MLJFlux.ImageClassifier","text":"ImageClassifier\n\nA model type for constructing a image classifier, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nImageClassifier = @load ImageClassifier pkg=MLJFlux\n\nDo model = ImageClassifier() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in ImageClassifier(builder=...).\n\nImageClassifier classifies images using a neural network adapted to the type of images provided (color or gray scale). Predictions are probabilistic. Users provide a recipe for constructing the network, based on properties of the image encountered, by specifying an appropriate builder. See MLJFlux documentation for more on builders.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX is any AbstractVector of images with ColorImage or GrayImage scitype; check  the scitype with scitype(X) and refer to ScientificTypes.jl documentation on coercing  typical image formats into an appropriate type.\ny is the target, which can be any AbstractVector whose element  scitype is Multiclass; check the scitype with scitype(y).\n\nTrain the machine with fit!(mach, rows=...).\n\nHyper-parameters\n\nbuilder: An MLJFlux builder that constructs the neural network.  The fallback builds a  depth-16 VGG architecture adapted to the image size and number of target classes, with  no batch normalization; see the Metalhead.jl documentation for details. See the example  below for a user-specified builder. A convenience macro @builder is also  available. See also finaliser below.\noptimiser::Optimisers.Adam(): An Optimisers.jl optimiser. The optimiser performs the updating of the weights of the network. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.crossentropy: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a classification task, the most natural loss functions are:\nFlux.crossentropy: Standard multiclass classification loss, also known as the log loss.\nFlux.logitcrossentopy: Mathematically equal to crossentropy, but numerically more stable than finalising the outputs with softmax and then calculating crossentropy. You will need to specify finaliser=identity to remove MLJFlux's default softmax finaliser, and understand that the output of predict is then unnormalized (no longer probabilistic).\nFlux.tversky_loss: Used with imbalanced data to give more weight to false negatives.\nFlux.focal_loss: Used with highly imbalanced data. Weights harder examples more than easier examples.\nCurrently MLJ measures are not supported values of loss.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights. Typically, batch size is between 8 and\nIncreassing batch size may accelerate training if acceleration=CUDALibs() and a\nGPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞). Note the history reports unpenalized losses.\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training. The default is Random.default_rng().\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\nfinaliser=Flux.softmax: The final activation function of the neural network (applied after the network defined by builder). Defaults to Flux.softmax.\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew, which should have the same scitype as X above. Predictions are probabilistic but uncalibrated.\npredict_mode(mach, Xnew): Return the modes of the probabilistic predictions returned above.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers,  functions, and activations  which make up the neural network. This includes  the final layer specified by finaliser (eg, softmax).\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalised if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we use MLJFlux and a custom builder to classify the MNIST image dataset.\n\nusing MLJ\nusing Flux\nimport MLJFlux\nimport MLJIteration # for `skip` control\n\nFirst we want to download the MNIST dataset, and unpack into images and labels:\n\nimport MLDatasets: MNIST\ndata = MNIST(split=:train)\nimages, labels = data.features, data.targets\n\nIn MLJ, integers cannot be used for encoding categorical data, so we must coerce them into the Multiclass scitype:\n\nlabels = coerce(labels, Multiclass);\n\nAbove images is a single array but MLJFlux requires the images to be a vector of individual image arrays:\n\nimages = coerce(images, GrayImage);\nimages[1]\n\nWe start by defining a suitable builder object. This is a recipe for building the neural network. Our builder will work for images of any (constant) size, whether they be color or black and white (ie, single or multi-channel).  The architecture always consists of six alternating convolution and max-pool layers, and a final dense layer; the filter size and the number of channels after each convolution layer is customizable.\n\nimport MLJFlux\n\nstruct MyConvBuilder\n    filter_size::Int\n    channels1::Int\n    channels2::Int\n    channels3::Int\nend\n\nmake2d(x::AbstractArray) = reshape(x, :, size(x)[end])\n\nfunction MLJFlux.build(b::MyConvBuilder, rng, n_in, n_out, n_channels)\n    k, c1, c2, c3 = b.filter_size, b.channels1, b.channels2, b.channels3\n    mod(k, 2) == 1 || error(\"`filter_size` must be odd. \")\n    p = div(k - 1, 2) # padding to preserve image size\n    init = Flux.glorot_uniform(rng)\n    front = Chain(\n        Conv((k, k), n_channels => c1, pad=(p, p), relu, init=init),\n        MaxPool((2, 2)),\n        Conv((k, k), c1 => c2, pad=(p, p), relu, init=init),\n        MaxPool((2, 2)),\n        Conv((k, k), c2 => c3, pad=(p, p), relu, init=init),\n        MaxPool((2 ,2)),\n        make2d)\n    d = Flux.outputsize(front, (n_in..., n_channels, 1)) |> first\n    return Chain(front, Dense(d, n_out, init=init))\nend\n\nIt is important to note that in our build function, there is no final softmax. This is applied by default in all MLJFlux classifiers (override this using the finaliser hyperparameter).\n\nNow that our builder is defined, we can instantiate the actual MLJFlux model. If you have a GPU, you can substitute in acceleration=CUDALibs() below to speed up training.\n\nImageClassifier = @load ImageClassifier pkg=MLJFlux\nclf = ImageClassifier(builder=MyConvBuilder(3, 16, 32, 32),\n                      batch_size=50,\n                      epochs=10,\n                      rng=123)\n\nYou can add Flux options such as optimiser and loss in the snippet above. Currently, loss must be a flux-compatible loss, and not an MLJ measure.\n\nNext, we can bind the model with the data in a machine, and train using the first 500 images:\n\nmach = machine(clf, images, labels);\nfit!(mach, rows=1:500, verbosity=2);\nreport(mach)\nchain = fitted_params(mach)\nFlux.params(chain)[2]\n\nWe can tack on 20 more epochs by modifying the epochs field, and iteratively fit some more:\n\nclf.epochs = clf.epochs + 20\nfit!(mach, rows=1:500, verbosity=2);\n\nWe can also make predictions and calculate an out-of-sample loss estimate, using any MLJ measure (loss/score):\n\npredicted_labels = predict(mach, rows=501:1000);\ncross_entropy(predicted_labels, labels[501:1000]) |> mean\n\nThe preceding fit!/predict/evaluate workflow can be alternatively executed as follows:\n\nevaluate!(mach,\n          resampling=Holdout(fraction_train=0.5),\n          measure=cross_entropy,\n          rows=1:1000,\n          verbosity=0)\n\nSee also NeuralNetworkClassifier.\n\n\n\n\n\n","category":"type"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"EditURL = \"tuning.jl\"","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/#Hyperparameter-Tuning-with-MLJFlux","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning with MLJFlux","text":"","category":"section"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"In this workflow example we learn how to tune different hyperparameters of MLJFlux models with emphasis on training hyperparameters.","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/#Basic-Imports","page":"Hyperparameter Tuning","title":"Basic Imports","text":"","category":"section"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nusing Plots             # To plot tuning results","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/#Loading-and-Splitting-the-Data","page":"Hyperparameter Tuning","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng=123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nnothing #hide","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/#Instantiating-the-model","page":"Hyperparameter Tuning","title":"Instantiating the model","text":"","category":"section"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Now let's construct our model. This follows a similar setup the one followed in the Quick Start.","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Flux.ADAM(0.01),\n    batch_size=8,\n    epochs=10,\n    rng=42\n    )","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/#Hyperparameter-Tuning-Example","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning Example","text":"","category":"section"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Let's tune the batch size and the learning rate. We will use grid search and 5-fold cross-validation.","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"We start by defining the hyperparameter ranges","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"r1 = range(clf, :batch_size, lower=1, upper=64)\nr2 = range(clf, :(optimiser.eta), lower=10^-4, upper=10^0, scale=:log10)","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Then passing the ranges along with the model and other arguments to the TunedModel constructor.","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"tuned_model = TunedModel(\n    model=clf,\n    tuning=Grid(goal=25),\n    resampling=CV(nfolds=5, rng=42),\n    range=[r1, r2],\n    measure=cross_entropy,\n);\nnothing #hide","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Then wrapping our tuned model in a machine and fitting it.","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"mach = machine(tuned_model, X, y);\nfit!(mach, verbosity=0);\nnothing #hide","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Let's check out the best performing model:","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"fitted_params(mach).best_model","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"We can visualize the hyperparameter search results as follows","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"plot(mach)","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/#Learning-Curves","page":"Hyperparameter Tuning","title":"Learning Curves","text":"","category":"section"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"With learning curves, it's possible to center our focus on the effects of a single hyperparameter of the model","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"First define the range and wrap it in a learning curve","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"r = range(clf, :epochs, lower=1, upper=200, scale=:log10)\ncurve = learning_curve(clf, X, y,\n                       range=r,\n                       resampling=CV(nfolds=4, rng=42),\n                       measure=cross_entropy)","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Then plot the curve","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"plot(curve.parameter_values,\n       curve.measurements,\n       xlab=curve.parameter_name,\n       xscale=curve.parameter_scale,\n       ylab = \"Cross Entropy\")","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"","category":"page"},{"location":"workflow examples/Hyperparameter Tuning/tuning/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/Summary/#Models","page":"Summary","title":"Models","text":"","category":"section"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"MLJFlux provides four model types, for use with input features X and targets y of the scientific type indicated in the table below. The parameters n_in, n_out and n_channels refer to information passed to the builder, as described under Defining a new builder below.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Model Type Prediction type scitype(X) <: _ scitype(y) <: _\nNeuralNetworkRegressor Deterministic Table(Continuous) with n_in columns AbstractVector{<:Continuous) (n_out = 1)\nMultitargetNeuralNetworkRegressor Deterministic Table(Continuous) with n_in columns <: Table(Continuous) with n_out columns\nNeuralNetworkClassifier Probabilistic <:Table(Continuous) with n_in columns AbstractVector{<:Finite} with n_out classes\nImageClassifier Probabilistic AbstractVector(<:Image{W,H}) with n_in = (W, H) AbstractVector{<:Finite} with n_out classes","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"<details><summary><b>See definition of \"model\"</b></summary>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"In MLJ a model is a mutable struct storing hyper-parameters for some learning algorithm indicated by the model name, and that's all. In particular, an MLJ model does not store learned parameters.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"warning: Difference in Definition\nIn Flux the term \"model\" has another meaning. However, as all Flux \"models\" used in MLJFLux are Flux.Chain objects, we call them chains, and restrict use of \"model\" to models in the MLJ sense.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"</details>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"<details open><summary><b>Dealing with non-tabular input</b></summary>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Any AbstractMatrix{<:AbstractFloat} object Xmat can be forced to have scitype Table(Continuous) by replacing it with X = MLJ.table(Xmat). Furthermore, this wrapping, and subsequent unwrapping under the hood, will compile to a no-op. At present this includes support for sparse matrix data, but the implementation has not been optimized for sparse data at this time and so should be used with caution.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Instructions for coercing common image formats into some AbstractVector{<:Image} are here.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"</details>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"<details closed><summary><b>Fitting and warm restarts</b></summary>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"MLJ machines cache state enabling the \"warm restart\" of model training, as demonstrated in the incremental training example. In the case of MLJFlux models, fit!(mach) will use a warm restart if:","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"only model.epochs has changed since the last call; or\nonly model.epochs or model.optimiser have changed since the last call and model.optimiser_changes_trigger_retraining == false (the default) (the \"state\" part of the optimiser is ignored in this comparison). This allows one to dynamically modify learning rates, for example.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Here model=mach.model is the associated MLJ model.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"The warm restart feature makes it possible to apply early stopping criteria, as defined in EarlyStopping.jl. For an example, see /examples/mnist/. (Eventually, this will be handled by an MLJ model wrapper for controlling arbitrary iterative models.)","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"</details>","category":"page"},{"location":"interface/Summary/#Model-Hyperparameters.","page":"Summary","title":"Model Hyperparameters.","text":"","category":"section"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"All models share the following hyper-parameters:","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Hyper-parameter Description Default\nbuilder Default builder for models. MLJFlux.Linear(σ=Flux.relu) (regressors) or MLJFlux.Short(n_hidden=0, dropout=0.5, σ=Flux.σ) (classifiers)\noptimiser The optimiser to use for training. Flux.ADAM()\nloss The loss function used for training. Flux.mse (regressors) and Flux.crossentropy (classifiers)\nn_epochs Number of epochs to train for. 10\nbatch_size The batch size for the data. 1\nlambda The regularization strength. Range = [0, ∞). 0\nalpha The L2/L1 mix of regularization. Range = [0, 1]. 0\nrng The random number generator (RNG) passed to builders, for weight initialization, for example. Can be any AbstractRNG or the seed (integer) for a MersenneTwister that is reset on every cold restart of model (machine) training. GLOBAL_RNG\nacceleration Use CUDALibs() for training on GPU; default is CPU1(). CPU1()\noptimiser_changes_trigger_retraining True if fitting an associated machine should trigger retraining from scratch whenever the optimiser changes. false","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"The classifiers have an additional hyperparameter finaliser (default = Flux.softmax) which is the operation applied to the unnormalized output of the final layer to obtain probabilities (outputs summing to one). Default = Flux.softmax. It should return a vector of the same length as its input.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"note: Loss Functions\nCurrently, the loss function specified by loss=... is applied internally by Flux and needs to conform to the Flux API. You cannot, for example, supply one of MLJ's probabilistic loss functions, such as MLJ.cross_entropy to one of the classifier constructors. ","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"That said, you can only use MLJ loss functions or metrics in evaluation meta-algorithms (such as cross validation) and they will work even if the underlying model comes from MLJFlux.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"<details closed><summary><b>More on accelerated training with GPUs</b></summary>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"As in the table, when instantiating a model for training on a GPU, specify acceleration=CUDALibs(), as in","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"using MLJ\nImageClassifier = @load ImageClassifier\nmodel = ImageClassifier(epochs=10, acceleration=CUDALibs())\nmach = machine(model, X, y) |> fit!","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"In this example, the data X, y is copied onto the GPU under the hood on the call to fit! and cached for use in any warm restart (see above). The Flux chain used in training is always copied back to the CPU at then conclusion of fit!, and made available as fitted_params(mach).","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"</details>","category":"page"},{"location":"interface/Summary/#Built-in-builders","page":"Summary","title":"Built-in builders","text":"","category":"section"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"As for the builder argument, the following builders are provided out-of-the-box:","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Builder Description\nMLJFlux.MLP(hidden=(10,)) General multi-layer perceptron\nMLJFlux.Short(n_hidden=0, dropout=0.5, σ=sigmoid) Fully connected network with one hidden layer and dropout\nMLJFlux.Linear(σ=relu) Vanilla linear network with no hidden layers and activation function σ","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"See the following sections to learn more about the interface for the builders and models.","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"EditURL = \"iteration.jl\"","category":"page"},{"location":"workflow examples/Early Stopping/iteration/#Early-Stopping-with-MLJFlux","page":"Early Stopping","title":"Early Stopping with MLJFlux","text":"","category":"section"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"In this workflow example, we learn how MLJFlux enables us to easily use early stopping when training MLJFlux models.","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"workflow examples/Early Stopping/iteration/#Basic-Imports","page":"Early Stopping","title":"Basic Imports","text":"","category":"section"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nusing Plots         # To visualize training","category":"page"},{"location":"workflow examples/Early Stopping/iteration/#Loading-and-Splitting-the-Data","page":"Early Stopping","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng=123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nnothing #hide","category":"page"},{"location":"workflow examples/Early Stopping/iteration/#Instantiating-the-model","page":"Early Stopping","title":"Instantiating the model","text":"","category":"section"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"Now let's construct our model. This follows a similar setup to the one followed in the Quick Start.","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Flux.ADAM(0.01),\n    batch_size=8,\n    epochs=50,\n    rng=42\n    )","category":"page"},{"location":"workflow examples/Early Stopping/iteration/#Wrapping-it-in-an-IteratedModel","page":"Early Stopping","title":"Wrapping it in an IteratedModel","text":"","category":"section"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"Let's start by defining the condition that can cause the model to early stop.","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"stop_conditions = [\n    Step(1),            # Repeatedly train for one iteration\n    NumberLimit(100),   # Don't train for more than 100 iterations\n    Patience(5),        # Stop after 5 iterations of disimprovement in validation loss\n    NumberSinceBest(9), # Or if the best loss occurred 9 iterations ago\n    TimeLimit(30/60),   # Or if 30 minutes passed\n]","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"We can also define callbacks. Here we want to store the validation loss for each iteration","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"validation_losses =  []\ncallbacks = [\n    WithLossDo(loss->push!(validation_losses, loss)),\n]","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"Construct the iterated model and pass to it the stop_conditions and the callbacks:","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"iterated_model = IteratedModel(model=clf,\n                               resampling=CV(nfolds=6),    # Split the data internally into 0.7 training and 0.3 validation\n                               measures=log_loss,\n                               iteration_parameter=:(epochs),\n                               controls=vcat(stop_conditions, callbacks),\n                               retrain=false                  # no need to retrain on all data at the end\n                               );\nnothing #hide","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"You can see more advanced stopping conditions as well as how to involve callbacks in the documentation","category":"page"},{"location":"workflow examples/Early Stopping/iteration/#Training-with-Early-Stopping","page":"Early Stopping","title":"Training with Early Stopping","text":"","category":"section"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"At this point, all we need is to fit the model and iteration controls will be automatically handled","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"mach = machine(iterated_model, X, y)\nfit!(mach)\n# We can get the training losses like so\ntraining_losses = report(mach)[:model_report].training_losses;\nnothing #hide","category":"page"},{"location":"workflow examples/Early Stopping/iteration/#Results","page":"Early Stopping","title":"Results","text":"","category":"section"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"We can see that the model converged after 100 iterations.","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"plot(training_losses, label=\"Training Loss\", linewidth=2)\nplot!(validation_losses, label=\"Validation Loss\", linewidth=2, size=(800,400))","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"using Literate #src","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"","category":"page"},{"location":"workflow examples/Early Stopping/iteration/","page":"Early Stopping","title":"Early Stopping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"EditURL = \"SMS.jl\"","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/#SMS-Spam-Detection-with-RNNs","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"","category":"section"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"In this tutorial we use a custom RNN model from Flux with MLJFlux to classify text messages as spam or ham. We will be using the SMS Collection Dataset from Kaggle.","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/#Basic-Imports","page":"SMS Spam Detection with RNNs","title":"Basic Imports","text":"","category":"section"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"using MLJ\nusing MLJFlux\nusing Flux\nusing CSV               # Read data\nusing DataFrames        # Read data\nusing ScientificTypes   # Type coercion\nusing WordTokenizers    # For tokenization\nusing Languages         # For stop words","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/#Reading-Data","page":"SMS Spam Detection with RNNs","title":"Reading Data","text":"","category":"section"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"df = CSV.read(\"./sms.csv\", DataFrame);","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Display the first 5 rows with DataFrames","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"first(df, 5) |> pretty","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"┌──────────┬─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ Category │ Message                                                                                                                                                     │\n│ String7  │ String                                                                                                                                                      │\n│ Textual  │ Textual                                                                                                                                                     │\n├──────────┼─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ ham      │ Go until jurong point, crazy.. Available only in bugis n great world la e buffet... Cine there got amore wat...                                             │\n│ ham      │ Ok lar... Joking wif u oni...                                                                                                                               │\n│ spam     │ Free entry in 2 a wkly comp to win FA Cup final tkts 21st May 2005. Text FA to 87121 to receive entry question(std txt rate)T&C's apply 08452810075over18's │\n│ ham      │ U dun say so early hor... U c already then say...                                                                                                           │\n│ ham      │ Nah I don't think he goes to usf, he lives around here though                                                                                               │\n└──────────┴─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\n","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/#Text-Preprocessing","page":"SMS Spam Detection with RNNs","title":"Text Preprocessing","text":"","category":"section"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Let's define a function that given an SMS message would:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Tokenize it (i.e., convert it into a vector of words)\nRemove stop words (i.e., words that are not useful for the analysis, like \"the\", \"a\", etc.)\nReturn the filtered vector of words","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"function preprocess_text(text)\n\t# (1) Splitting texts into words (so later it can be a sequence of vectors)\n\ttokens = WordTokenizers.tokenize(text)\n\n\t# (2) Stop word removal\n\tstop_words = Languages.stopwords(Languages.English())\n\tfiltered_tokens = filter(token -> !(token in stop_words), tokens)\n\n\treturn filtered_tokens\nend","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"preprocess_text (generic function with 1 method)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Define the vocabulary to be the set of all words in our training set. We also need a function that would map each word in a given sequence of words into its index in the dictionary (which is equivalent to representing the words as one-hot vectors).","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Now after we do this the sequences will all be numerical vectors but they will be of unequal length. Thus, to facilitate batching of data for the deep learning model, we need to decide on a specific maximum length for all sequences and:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"If a sequence is longer than the maximum length, we need to truncate it\nIf a sequence is shorter than the maximum length, we need to pad it with a new token","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Lastly, we must also handle the case that an incoming text sequence may involve words never seen in training by represent all such out-of-vocabulary words with a new token.","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"We will define a function that would do this for us.","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"function encode_and_equalize(text_seq, vocab_dict, max_length, pad_val, oov_val)\n\t# (1) encode using the vocabulary\n\ttext_seq_inds = [get(vocab_dict, word, oov_val) for word in text_seq]\n\n\t# (2) truncate sequence if > max_length\n\tlength(text_seq_inds) > max_length && (text_seq_inds = text_seq_inds[1:max_length])\n\n\t# (3) pad with pad_val\n\ttext_seq_inds = vcat(text_seq_inds, fill(pad_val, max_length - length(text_seq_inds)))\n\n\treturn text_seq_inds\nend","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"encode_and_equalize (generic function with 1 method)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/#Preparing-Data","page":"SMS Spam Detection with RNNs","title":"Preparing Data","text":"","category":"section"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Splitting the data","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"x_data, y_data = unpack(df, ==(:Message), ==(:Category))\ny_data = coerce(y_data, Multiclass);\n\n(x_train, x_val), (y_train, y_val) = partition((x_data, y_data), 0.8,\n\tmulti = true,\n\tshuffle = true,\n\trng = 42);","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Now let's process the training and validation sets:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"x_train_processed = [preprocess_text(text) for text in x_train]\nx_val_processed = [preprocess_text(text) for text in x_val];","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"sanity check","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"println(x_train_processed[1], \" is \", y_data[1])","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"[\"Que\", \"pases\", \"un\", \"buen\", \"tiempo\"] is ham\n","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Define the vocabulary from the training data","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"vocab = unique(vcat(x_train_processed...))\nvocab_dict = Dict(word => idx for (idx, word) in enumerate(vocab))\nvocab_size = length(vocab)\npad_val, oov_val = vocab_size + 1, vocab_size + 2\nmax_length = 12                 # can choose this more smartly if you wish","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"12","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Encode and equalize training and validation data:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"x_train_processed_equalized = [\n\tencode_and_equalize(seq, vocab_dict, max_length, pad_val, oov_val) for\n\tseq in x_train_processed\n]\nx_val_processed_equalized = [\n\tencode_and_equalize(seq, vocab_dict, max_length, pad_val, oov_val) for\n\tseq in x_val_processed\n]\nx_train_processed_equalized[1:5]          # all sequences are encoded and of the same length","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"5-element Vector{Vector{Int64}}:\n [1, 2, 3, 4, 5, 10404, 10404, 10404, 10404, 10404, 10404, 10404]\n [6, 7, 8, 9, 10, 11, 12, 13, 11, 14, 15, 16]\n [36, 37, 38, 39, 36, 40, 41, 42, 10404, 10404, 10404, 10404]\n [43, 24, 36, 44, 45, 46, 10404, 10404, 10404, 10404, 10404, 10404]\n [43, 47, 48, 49, 50, 51, 52, 53, 54, 55, 44, 45]","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Convert both structures into matrix form:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"matrixify(v) = reduce(hcat, v)'\nx_train_processed_equalized_fixed = matrixify(x_train_processed_equalized)\nx_val_processed_equalized_fixed = matrixify(x_val_processed_equalized)\nsize(x_train_processed_equalized_fixed)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"(4458, 12)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/#Instantiate-Model","page":"SMS Spam Detection with RNNs","title":"Instantiate Model","text":"","category":"section"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"For the model, we will use a RNN from Flux. We will average the hidden states corresponding to any sequence then pass that to a dense layer for classification.","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"For this, we need to define a custom Flux layer to perform the averaging operation:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"struct Mean end\nFlux.@layer Mean\n(m::Mean)(x) = mean(x, dims = 2)[:, 1, :]   # [batch_size, seq_len, hidden_dim] => [batch_size, 1, hidden_dim]=> [batch_size, hidden_dim]","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"For compatibility, we will also define a layer that simply casts the input to integers as the embedding layer in Flux expects integets but the MLJFlux model expects floats:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"struct Intify end\nFlux.@layer Intify\n(m::Intify)(x) = Int.(x)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Here we define out network:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"builder = MLJFlux.@builder begin\n\tChain(\n\t\tIntify(),                         # Cast input to integer\n\t\tEmbedding(vocab_size + 2 => 300),  # Embedding layer\n\t\tRNN(300, 50, tanh),               # RNN layer\n\t\tMean(),                           # Mean pooling layer\n\t\tDense(50, 2)                     # Classification dense layer\n\t)\nend","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"GenericBuilder(apply = #15)\n","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Notice that we used an embedding layer with input dimensionality vocab_size + 2 to take into account the padding and out-of-vocabulary tokens. Recall that the indices in our input correspond to one-hot-vectors and the embedding layer's purpose is to learn to map them into meaningful dense vectors (of dimensionality 300 here).","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Load and instantiate model","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg = MLJFlux\nclf = NeuralNetworkClassifier(\n\tbuilder = builder,\n\toptimiser = Flux.ADAM(0.1),\n\tbatch_size = 128,\n\tepochs = 10,\n)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"NeuralNetworkClassifier(\n  builder = GenericBuilder(\n        apply = Main.var\"##445\".var\"#15#16\"()), \n  finaliser = NNlib.softmax, \n  optimiser = Flux.Optimise.Adam(0.1, (0.9, 0.999), 1.0e-8, IdDict{Any, Any}()), \n  loss = Flux.Losses.crossentropy, \n  epochs = 10, \n  batch_size = 128, \n  lambda = 0.0, \n  alpha = 0.0, \n  rng = Random._GLOBAL_RNG(), \n  optimiser_changes_trigger_retraining = false, \n  acceleration = ComputationalResources.CPU1{Nothing}(nothing))","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Wrap it in a machine","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"x_train_processed_equalized_fixed = coerce(x_train_processed_equalized_fixed, Continuous)\nmach = machine(clf, x_train_processed_equalized_fixed, y_train)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"untrained Machine; caches model-specific representations of data\n  model: NeuralNetworkClassifier(builder = GenericBuilder(apply = #15), …)\n  args: \n    1:\tSource @029 ⏎ AbstractMatrix{ScientificTypesBase.Continuous}\n    2:\tSource @942 ⏎ AbstractVector{ScientificTypesBase.Multiclass{2}}\n","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/#Train-the-Model","page":"SMS Spam Detection with RNNs","title":"Train the Model","text":"","category":"section"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"fit!(mach)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"trained Machine; caches model-specific representations of data\n  model: NeuralNetworkClassifier(builder = GenericBuilder(apply = #15), …)\n  args: \n    1:\tSource @029 ⏎ AbstractMatrix{ScientificTypesBase.Continuous}\n    2:\tSource @942 ⏎ AbstractVector{ScientificTypesBase.Multiclass{2}}\n","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/#Evaluate-the-Model","page":"SMS Spam Detection with RNNs","title":"Evaluate the Model","text":"","category":"section"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"ŷ = predict_mode(mach, x_val_processed_equalized_fixed)\nbalanced_accuracy(ŷ, y_val)","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"0.9370418555201171","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"Acceptable performance. Let's see some live examples:","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"using Random: Random;\nRandom.seed!(99);\n\nz = rand(x_val)\nz_processed = preprocess_text(z)\nz_encoded_equalized =\n\tencode_and_equalize(z_processed, vocab_dict, max_length, pad_val, oov_val)\nz_encoded_equalized_fixed = matrixify([z_encoded_equalized])\nz_encoded_equalized_fixed = coerce(z_encoded_equalized_fixed, Continuous)\nz_pred = predict_mode(mach, z_encoded_equalized_fixed)\n\nprint(\"SMS: `$(z)` and the prediction is `$(z_pred)`\")","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"SMS: `Hi elaine, is today's meeting confirmed?` and the prediction is `CategoricalArrays.CategoricalValue{InlineStrings.String7, UInt32}[InlineStrings.String7(\"ham\")]`","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"","category":"page"},{"location":"full tutorials/Spam Detection with RNNs/SMS/","page":"SMS Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"EditURL = \"composition.jl\"","category":"page"},{"location":"workflow examples/Composition/composition/#Model-Composition-with-MLJFlux","page":"Model Composition","title":"Model Composition with MLJFlux","text":"","category":"section"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"In this workflow example, we see how MLJFlux enables composing MLJ models with MLJFlux models. We will assume a class imbalance setting and wrap an oversampler with a deep learning model from MLJFlux.","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"workflow examples/Composition/composition/#Basic-Imports","page":"Model Composition","title":"Basic Imports","text":"","category":"section"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nimport Random           # To create imbalance\nimport Imbalance        # To solve the imbalance","category":"page"},{"location":"workflow examples/Composition/composition/#Loading-and-Splitting-the-Data","page":"Model Composition","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng=123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nnothing #hide","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"To simulate an imbalanced dataset, we will take a random sample:","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"Random.seed!(803429)\nsubset_indices = rand(1:size(X, 1), 100)\nX, y = X[subset_indices, :], y[subset_indices]\nImbalance.checkbalance(y)","category":"page"},{"location":"workflow examples/Composition/composition/#Instantiating-the-model","page":"Model Composition","title":"Instantiating the model","text":"","category":"section"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"Let's load BorderlineSMOTE1 to oversample the data and Standardizer to standardize it.","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"BorderlineSMOTE1 = @load BorderlineSMOTE1 pkg=Imbalance verbosity=0\nNeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n# We didn't need to load Standardizer because it is a  local model for MLJ (see `localmodels()`)\n\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Flux.ADAM(0.01),\n    batch_size=8,\n    epochs=50,\n    rng=42\n    )","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"First we wrap the oversampler with the neural network via the BalancedModel construct. This comes from MLJBalancing And allows combining resampling methods with MLJ models in a sequential pipeline.","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"oversampler = BorderlineSMOTE1(k=5, ratios=1.0, rng=42)\nbalanced_model = BalancedModel(model=clf, balancer1=oversampler)\nstandarizer = Standardizer()","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"Now let's compose the balanced model with a standardizer.","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"pipeline = standarizer |> balanced_model","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"By this, any training data will be standardized then oversampled then passed to the model. Meanwhile, for inference, the standardizer will automatically use the training set's mean and std and the oversampler will be transparent.","category":"page"},{"location":"workflow examples/Composition/composition/#Training-the-Composed-Model","page":"Model Composition","title":"Training the Composed Model","text":"","category":"section"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"It's indistinguishable from training a single model.","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"mach = machine(pipeline, X, y)\nfit!(mach)\ncv=CV(nfolds=5)\nevaluate!(mach, resampling=cv, measure=accuracy)","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"","category":"page"},{"location":"workflow examples/Composition/composition/","page":"Model Composition","title":"Model Composition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/Classification/","page":"Classification","title":"Classification","text":"MLJFlux.NeuralNetworkClassifier","category":"page"},{"location":"interface/Classification/#MLJFlux.NeuralNetworkClassifier","page":"Classification","title":"MLJFlux.NeuralNetworkClassifier","text":"NeuralNetworkClassifier\n\nA model type for constructing a neural network classifier, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nNeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n\nDo model = NeuralNetworkClassifier() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in NeuralNetworkClassifier(builder=...).\n\nNeuralNetworkClassifier is for training a data-dependent Flux.jl neural network for making probabilistic predictions of a Multiclass or OrderedFactor target, given a table of Continuous features. Users provide a recipe for constructing  the network, based on properties of the data that is encountered, by specifying  an appropriate builder. See MLJFlux documentation for more on builders.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX is either a Matrix or any table of input features (eg, a DataFrame) whose columns are of scitype Continuous; check column scitypes with schema(X). If X is a Matrix, it is assumed to have columns corresponding to features and rows corresponding to observations.\ny is the target, which can be any AbstractVector whose element scitype is Multiclass or OrderedFactor; check the scitype with scitype(y)\n\nTrain the machine with fit!(mach, rows=...).\n\nHyper-parameters\n\nbuilder=MLJFlux.Short(): An MLJFlux builder that constructs a neural network. Possible  builders include: MLJFlux.Linear, MLJFlux.Short, and MLJFlux.MLP. See  MLJFlux.jl documentation for examples of user-defined builders. See also finaliser  below.\noptimiser::Optimisers.Adam(): An Optimisers.jl optimiser. The optimiser performs the updating of the weights of the network. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.crossentropy: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a classification task, the most natural loss functions are:\nFlux.crossentropy: Standard multiclass classification loss, also known as the log loss.\nFlux.logitcrossentopy: Mathematically equal to crossentropy, but numerically more stable than finalising the outputs with softmax and then calculating crossentropy. You will need to specify finaliser=identity to remove MLJFlux's default softmax finaliser, and understand that the output of predict is then unnormalized (no longer probabilistic).\nFlux.tversky_loss: Used with imbalanced data to give more weight to false negatives.\nFlux.focal_loss: Used with highly imbalanced data. Weights harder examples more than easier examples.\nCurrently MLJ measures are not supported values of loss.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights. Typically, batch size is between 8 and\nIncreassing batch size may accelerate training if acceleration=CUDALibs() and a\nGPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞). Note the history reports unpenalized losses.\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training. The default is Random.default_rng().\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\nfinaliser=Flux.softmax: The final activation function of the neural network (applied after the network defined by builder). Defaults to Flux.softmax.\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew, which should have the same scitype as X above. Predictions are probabilistic but uncalibrated.\npredict_mode(mach, Xnew): Return the modes of the probabilistic predictions returned above.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers,  functions, and activations which make up the neural network. This includes  the final layer specified by finaliser (eg, softmax).\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalised if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we build a classification model using the Iris dataset. This is a very basic example, using a default builder and no standardization.  For a more advanced illustration, see NeuralNetworkRegressor or ImageClassifier, and examples in the MLJFlux.jl documentation.\n\nusing MLJ\nusing Flux\nimport RDatasets\n\nFirst, we can load the data:\n\niris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng=123); # a vector and a table\nNeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\nclf = NeuralNetworkClassifier()\n\nNext, we can train the model:\n\nmach = machine(clf, X, y)\nfit!(mach)\n\nWe can train the model in an incremental fashion, altering the learning rate as we go, provided optimizer_changes_trigger_retraining is false (the default). Here, we also change the number of (total) iterations:\n\nclf.optimiser.eta = clf.optimiser.eta * 2\nclf.epochs = clf.epochs + 5\n\nfit!(mach, verbosity=2) # trains 5 more epochs\n\nWe can inspect the mean training loss using the cross_entropy function:\n\ntraining_loss = cross_entropy(predict(mach, X), y) |> mean\n\nAnd we can access the Flux chain (model) using fitted_params:\n\nchain = fitted_params(mach).chain\n\nFinally, we can see how the out-of-sample performance changes over time, using MLJ's learning_curve function:\n\nr = range(clf, :epochs, lower=1, upper=200, scale=:log10)\ncurve = learning_curve(clf, X, y,\n                     range=r,\n                     resampling=Holdout(fraction_train=0.7),\n                     measure=cross_entropy)\nusing Plots\nplot(curve.parameter_values,\n     curve.measurements,\n     xlab=curve.parameter_name,\n     xscale=curve.parameter_scale,\n     ylab = \"Cross Entropy\")\n\n\nSee also ImageClassifier.\n\n\n\n\n\n","category":"type"},{"location":"#MLJFlux.jl","page":"Introduction","title":"MLJFlux.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Julia package integrating deep learning Flux models with MLJ.","category":"page"},{"location":"#Objectives","page":"Introduction","title":"Objectives","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Provide a user-friendly and high-level interface to fundamental Flux deep learning models while still being extensible by supporting custom models written with Flux\nMake building deep learning models more convenient to users already familiar with the MLJ workflow\nMake it easier to apply machine learning techniques provided by MLJ, including: out-of-sample performance evaluation, hyper-parameter optimization, iteration control, and more, to deep learning models","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: MLJFlux Coverage\nMLJFlux support is focused on fundamental and widely used deep learning models.  Sophisticated architectures or techniques such as online learning, reinforcement learning, and adversarial networks are currently beyond its scope. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Also note that MLJFlux is limited to training models only when all training data fits into memory, though it still supports automatic batching of data.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.activate(\"my_environment\", shared=true)\nPkg.add([\"MLJ\", \"MLJFlux\", \"Flux\"])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You only need Flux if you need to build a custom architecture or experiment with different optimizers, loss functions and activations.","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using MLJ, Flux, MLJFlux\nimport RDatasets\n\n# 1. Load Data\niris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng=123);\n\n# 2. Load and instantiate model\nNeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=\"MLJFlux\"\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Flux.ADAM(0.01),\n    batch_size=8,\n    epochs=100, \n    acceleration=CUDALibs()         # For GPU support\n    )\n\n# 3. Wrap it in a machine \nmach = machine(clf, X, y)\n\n# 4. Evaluate the model\ncv=CV(nfolds=5)\nevaluate!(mach, resampling=cv, measure=accuracy) ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As you can see we were able to use MLJ functionality (i.e., cross validation) with a Flux deep learning model. All arguments provided also have defaults.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Notice that we were also able to define the neural network in a high-level fashion by only specifying the number of neurons in each hidden layer and the activation function. Meanwhile, MLJFlux was able to infer the input and output layer as well as use a suitable default for the loss function and output activation given the classification task. Notice as well that we did not need to implement a training or prediction loop as in Flux.","category":"page"},{"location":"#Basic-idea","page":"Introduction","title":"Basic idea","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"As in the example above, any MLJFlux model has a builder hyperparameter, an object encoding instructions for creating a neural network given the data that the model eventually sees (e.g., the number of classes in a classification problem). While each MLJ model has a simple default builder, users may need to define custom builders to get optimal results, and this will require familiarity with the Flux API for defining a neural network chain.","category":"page"},{"location":"#Flux-or-MLJFlux?","page":"Introduction","title":"Flux or MLJFlux?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Flux is a deep learning framework in Julia that comes with everything you need to build deep learning models (i.e., GPU support, automatic differentiation, layers, activations, losses, optimizers, etc.). MLJFlux wraps models built with Flux which provides a more high-level interface for building and training such models. More importantly, it empowers Flux models by extending their support to many common machine learning workflows that are possible via MLJ such as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Estimating performance of your model using a holdout set or other resampling strategy (e.g., cross-validation) as measured by one or more metrics (e.g., loss functions) that may not have been used in training\nOptimizing hyper-parameters such as a regularization parameter (e.g., dropout) or a width/height/nchannnels of convolution layer\nCompose with other models such as introducing data pre-processing steps (e.g., missing data imputation) into a pipeline. It might make sense to include non-deep learning models in this pipeline. Other kinds of model composition could include blending predictions of a deep learner with some other kind of model (as in “model stacking”). Models composed with MLJ can be also tuned as a single unit.\nControlling iteration by adding an early stopping criterion based on an out-of-sample estimate of the loss, dynamically changing the learning rate (eg, cyclic learning rates), periodically save snapshots of the model, generate live plots of sample weights to judge training progress (as in tensor board)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Comparing your model with a non-deep learning models","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A comparable project, FastAI/FluxTraining, also provides a high-level interface for interacting with Flux models and supports a set of features that may overlap with (but not include all of) those supported by MLJFlux.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Many of the features mentioned above are showcased in the workflow examples that you can access from the sidebar.","category":"page"},{"location":"full tutorials/MNIST/#Image-Classification-Example","page":"-","title":"Image Classification Example","text":"","category":"section"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"An expanded version of this example, with early stopping and snapshots, is available here.","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"We define a builder that builds a chain with six alternating convolution and max-pool layers, and a final dense layer, which we apply to the MNIST image dataset.","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"First we define a generic builder (working for any image size, color or gray):","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"using MLJ\nusing Flux\nusing MLDatasets\n\n# helper function\nfunction flatten(x::AbstractArray)\n\treturn reshape(x, :, size(x)[end])\nend\n\nimport MLJFlux\nmutable struct MyConvBuilder\n\tfilter_size::Int\n\tchannels1::Int\n\tchannels2::Int\n\tchannels3::Int\nend\n\nfunction MLJFlux.build(b::MyConvBuilder, rng, n_in, n_out, n_channels)\n\n\tk, c1, c2, c3 = b.filter_size, b.channels1, b.channels2, b.channels3\n\n\tmod(k, 2) == 1 || error(\"`filter_size` must be odd. \")\n\n\t# padding to preserve image size on convolution:\n\tp = div(k - 1, 2)\n\n\tfront = Chain(\n            Conv((k, k), n_channels => c1, pad=(p, p), relu),\n            MaxPool((2, 2)),\n            Conv((k, k), c1 => c2, pad=(p, p), relu),\n            MaxPool((2, 2)),\n            Conv((k, k), c2 => c3, pad=(p, p), relu),\n            MaxPool((2 ,2)),\n           flatten,\n           )\n\td = Flux.outputsize(front, (n_in..., n_channels, 1)) |> first\n\treturn Chain(front, Dense(d, n_out))\nend","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"Next, we load some of the MNIST data and check scientific types conform to those is the table above:","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"N = 500\nXraw, yraw = MNIST(split=:train)[:];\nXraw = Xraw[:,:,1:N];\nyraw = yraw[1:N];\n\nscitype(Xraw)","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"scitype(yraw)","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"Inputs should have element scitype GrayImage:","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"X = coerce(Xraw, GrayImage);","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"For classifiers, target must have element scitype <: Finite:","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"y = coerce(yraw, Multiclass);","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"Instantiating an image classifier model:","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"ImageClassifier = @load ImageClassifier\nclf = ImageClassifier(\n    builder=MyConvBuilder(3, 16, 32, 32),\n    epochs=10,\n    loss=Flux.crossentropy,\n    )","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"And evaluating the accuracy of the model on a 30% holdout set:","category":"page"},{"location":"full tutorials/MNIST/","page":"-","title":"-","text":"mach = machine(clf, X, y)\n\nevaluate!(\n    mach,\n    resampling=Holdout(rng=123, fraction_train=0.7),\n    measure=misclassification_rate,\n    )","category":"page"},{"location":"interface/Custom Builders/#Defining-Custom-Builders","page":"Custom Builders","title":"Defining Custom Builders","text":"","category":"section"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"Following is an example defining a new builder for creating a simple fully-connected neural network with two hidden layers, with n1 nodes in the first hidden layer, and n2 nodes in the second, for use in any of the first three models in Table 1. The definition includes one mutable struct and one method:","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"mutable struct MyBuilder <: MLJFlux.Builder\n\tn1 :: Int\n\tn2 :: Int\nend\n\nfunction MLJFlux.build(nn::MyBuilder, rng, n_in, n_out)\n\tinit = Flux.glorot_uniform(rng)\n        return Chain(\n            Dense(n_in, nn.n1, init=init),\n            Dense(nn.n1, nn.n2, init=init),\n            Dense(nn.n2, n_out, init=init),\n            )\nend","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"Note here that n_in and n_out depend on the size of the data (see Table 1.","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"For a concrete image classification example, see the Image Classification Example.","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"More generally, defining a new builder means defining a new struct sub-typing MLJFlux.Builder and defining a new MLJFlux.build method with one of these signatures:","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"MLJFlux.build(builder::MyBuilder, rng, n_in, n_out)\nMLJFlux.build(builder::MyBuilder, rng, n_in, n_out, n_channels) # for use with `ImageClassifier`","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"This method must return a Flux.Chain instance, chain, subject to the following conditions:","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"chain(x) must make sense:\nfor any x <: Array{<:AbstractFloat, 2} of size (n_in, batch_size) where batch_size is any integer (for use with one of the first three model types); or\nfor any x <: Array{<:Float32, 4} of size (W, H, n_channels, batch_size), where (W, H) = n_in, n_channels is 1 or 3, and batch_size is any integer (for use with ImageClassifier)\nThe object returned by chain(x) must be an AbstractFloat vector of length n_out.","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"Alternatively, use MLJFlux.@builder(neural_net) to automatically create a builder for any valid Flux chain expression neural_net, where the symbols n_in, n_out, n_channels and rng can appear literally, with the interpretations explained above. For example,","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"builder = MLJFlux.@builder Chain(Dense(n_in, 128), Dense(128, n_out, tanh))","category":"page"}]
}
