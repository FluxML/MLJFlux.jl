var documenterSearchIndex = {"docs":
[{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/#Hyperparameter-Tuning-with-MLJFlux","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning with MLJFlux","text":"","category":"section"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"This demonstration is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"In this workflow example we learn how to tune different hyperparameters of MLJFlux models with emphasis on training hyperparameters.","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/#Basic-Imports","page":"Hyperparameter Tuning","title":"Basic Imports","text":"","category":"section"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nusing Plots             # To plot tuning results\nimport Optimisers       # native Flux.jl optimisers no longer supported","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/#Loading-and-Splitting-the-Data","page":"Hyperparameter Tuning","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng=123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nnothing #hide","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/#Instantiating-the-model","page":"Hyperparameter Tuning","title":"Instantiating the model","text":"","category":"section"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Now let's construct our model. This follows a similar setup the one followed in the Quick Start.","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Optimisers.Adam(0.01),\n    batch_size=8,\n    epochs=10,\n    rng=42,\n)","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/#Hyperparameter-Tuning-Example","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning Example","text":"","category":"section"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Let's tune the batch size and the learning rate. We will use grid search and 5-fold cross-validation.","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"We start by defining the hyperparameter ranges","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"r1 = range(clf, :batch_size, lower=1, upper=64)\netas = [10^x for x in range(-4, stop=0, length=4)]\noptimisers = [Optimisers.Adam(eta) for eta in etas]\nr2 = range(clf, :optimiser, values=optimisers)","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Then passing the ranges along with the model and other arguments to the TunedModel constructor.","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"tuned_model = TunedModel(\n    model=clf,\n    tuning=Grid(goal=25),\n    resampling=CV(nfolds=5, rng=42),\n    range=[r1, r2],\n    measure=cross_entropy,\n);\nnothing #hide","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Then wrapping our tuned model in a machine and fitting it.","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"mach = machine(tuned_model, X, y);\nfit!(mach, verbosity=0);\nnothing #hide","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Let's check out the best performing model:","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"fitted_params(mach).best_model","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/#Learning-Curves","page":"Hyperparameter Tuning","title":"Learning Curves","text":"","category":"section"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"With learning curves, it's possible to center our focus on the effects of a single hyperparameter of the model","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"First define the range and wrap it in a learning curve","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"r = range(clf, :epochs, lower=1, upper=200, scale=:log10)\ncurve = learning_curve(\n    clf,\n    X,\n    y,\n    range=r,\n    resampling=CV(nfolds=4, rng=42),\n    measure=cross_entropy,\n)","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"Then plot the curve","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"plot(\n    curve.parameter_values,\n    curve.measurements,\n    xlab=curve.parameter_name,\n    xscale=curve.parameter_scale,\n    ylab = \"Cross Entropy\",\n)","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"","category":"page"},{"location":"common_workflows/hyperparameter_tuning/notebook/","page":"Hyperparameter Tuning","title":"Hyperparameter Tuning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"common_workflows/comparison/notebook/#Model-Comparison-with-MLJFlux","page":"Model Comparison","title":"Model Comparison with MLJFlux","text":"","category":"section"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"This demonstration is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"In this workflow example, we see how we can compare different machine learning models with a neural network from MLJFlux.","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"common_workflows/comparison/notebook/#Basic-Imports","page":"Model Comparison","title":"Basic Imports","text":"","category":"section"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nusing DataFrames        # To visualize hyperparameter search results\nimport Optimisers       # native Flux.jl optimisers no longer supported","category":"page"},{"location":"common_workflows/comparison/notebook/#Loading-and-Splitting-the-Data","page":"Model Comparison","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng=123);\nnothing #hide","category":"page"},{"location":"common_workflows/comparison/notebook/#Instantiating-the-models-Now-let's-construct-our-model.-This-follows-a-similar-setup","page":"Model Comparison","title":"Instantiating the models Now let's construct our model. This follows a similar setup","text":"","category":"section"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"to the one followed in the Quick Start.","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n\nclf1 = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Optimisers.Adam(0.01),\n    batch_size=8,\n    epochs=50,\n    rng=42\n    )","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"Let's as well load and construct three other classical machine learning models:","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"BayesianLDA = @load BayesianLDA pkg=MultivariateStats\nclf2 = BayesianLDA()\nRandomForestClassifier = @load RandomForestClassifier pkg=DecisionTree\nclf3 = RandomForestClassifier()\nXGBoostClassifier = @load XGBoostClassifier pkg=XGBoost\nclf4 = XGBoostClassifier();\nnothing #hide","category":"page"},{"location":"common_workflows/comparison/notebook/#Wrapping-One-of-the-Models-in-a-TunedModel","page":"Model Comparison","title":"Wrapping One of the Models in a TunedModel","text":"","category":"section"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"Instead of just comparing with four models with the default/given hyperparameters, we will give XGBoostClassifier an unfair advantage By wrapping it in a TunedModel that considers the best learning rate η for the model.","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"r1 = range(clf4, :eta, lower=0.01, upper=0.5, scale=:log10)\ntuned_model_xg = TunedModel(\n    model=clf4,\n    ranges=[r1],\n    tuning=Grid(resolution=10),\n    resampling=CV(nfolds=5, rng=42),\n    measure=cross_entropy,\n);\nnothing #hide","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"Of course, one can wrap each of the four in a TunedModel if they are interested in comparing the models over a large set of their hyperparameters.","category":"page"},{"location":"common_workflows/comparison/notebook/#Comparing-the-models","page":"Model Comparison","title":"Comparing the models","text":"","category":"section"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"We simply pass the four models to the models argument of the TunedModel construct","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"tuned_model = TunedModel(\n    models=[clf1, clf2, clf3, tuned_model_xg],\n    tuning=Explicit(),\n    resampling=CV(nfolds=5, rng=42),\n    measure=cross_entropy,\n);\nnothing #hide","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"Then wrapping our tuned model in a machine and fitting it.","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"mach = machine(tuned_model, X, y);\nfit!(mach, verbosity=0);\nnothing #hide","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"Now let's see the history for more details on the performance for each of the models","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"history = report(mach).history\nhistory_df = DataFrame(\n    mlp = [x[:model] for x in history],\n    measurement = [x[:measurement][1] for x in history],\n)\nsort!(history_df, [order(:measurement)])","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"This is Occam's razor in practice.","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"","category":"page"},{"location":"common_workflows/comparison/notebook/","page":"Model Comparison","title":"Model Comparison","text":"This page was generated using Literate.jl.","category":"page"},{"location":"contributing/#Adding-new-models-to-MLJFlux","page":"Contributing","title":"Adding new models to MLJFlux","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"This section assumes familiarity with the MLJ model API","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"If one subtypes a new model type as either MLJFlux.MLJFluxProbabilistic or MLJFlux.MLJFluxDeterministic, then instead of defining new methods for MLJModelInterface.fit and MLJModelInterface.update one can make use of fallbacks by implementing the lower level methods shape, build, and fitresult. See the classifier source code for an example.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"One still needs to implement a new predict method.","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"extended_examples/spam_detection/notebook/#SMS-Spam-Detection-with-RNNs","page":"Spam Detection with RNNs","title":"SMS Spam Detection with RNNs","text":"","category":"section"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"This demonstration is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"In this demo we use a custom RNN model from Flux with MLJFlux to classify text messages as spam or ham. We will be using the SMS Collection Dataset from Kaggle.","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Warning. This demo includes some non-idiomatic use of MLJ to allow use of the Flux.jl Embedding layer. It is not recommended for MLJ beginners.","category":"page"},{"location":"extended_examples/spam_detection/notebook/#Basic-Imports","page":"Spam Detection with RNNs","title":"Basic Imports","text":"","category":"section"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"using MLJ\nusing MLJFlux\nusing Flux\nimport Optimisers       # Flux.jl native optimisers no longer supported\nusing CSV               # Read data\nusing DataFrames        # Read data\nusing WordTokenizers    # For tokenization\nusing Languages         # For stop words","category":"page"},{"location":"extended_examples/spam_detection/notebook/#Reading-Data","page":"Spam Detection with RNNs","title":"Reading Data","text":"","category":"section"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"We assume the SMS Collection Dataset has been downloaded and is in a file called \"sms.csv\" in the same directory as the this script.","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"df = CSV.read(joinpath(@__DIR__, \"sms.csv\"), DataFrame);\nnothing #hide","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Display the first 5 rows with DataFrames","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"first(df, 5)","category":"page"},{"location":"extended_examples/spam_detection/notebook/#Text-Preprocessing","page":"Spam Detection with RNNs","title":"Text Preprocessing","text":"","category":"section"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Let's define a function that given an SMS message would:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Tokenize it (i.e., convert it into a vector of words)\nRemove stop words (i.e., words that are not useful for the analysis, like \"the\", \"a\", etc.)\nReturn the filtered vector of words","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"const STOP_WORDS = Languages.stopwords(Languages.English())\n\nfunction preprocess_text(text)\n    # (1) Splitting texts into words (so later it can be a sequence of vectors)\n    tokens = WordTokenizers.tokenize(text)\n\n    # (2) Stop word removal\n    filtered_tokens = filter(token -> !(token in STOP_WORDS), tokens)\n\n    return filtered_tokens\nend","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Define the vocabulary to be the set of all words in our training set. We also need a function that would map each word in a given sequence of words into its index in the dictionary (which is equivalent to representing the words as one-hot vectors).","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Now after we do this the sequences will all be numerical vectors but they will be of unequal length. Thus, to facilitate batching of data for the deep learning model, we need to decide on a specific maximum length for all sequences and:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"If a sequence is longer than the maximum length, we need to truncate it\nIf a sequence is shorter than the maximum length, we need to pad it with a new token","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Lastly, we must also handle the case that an incoming text sequence may involve words never seen in training by represent all such out-of-vocabulary words with a new token.","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"We will define a function that would do this for us.","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"function encode_and_equalize(text_seq, vocab_dict, max_length, pad_val, oov_val)\n    # (1) encode using the vocabulary\n    text_seq_inds = [get(vocab_dict, word, oov_val) for word in text_seq]\n\n    # (2) truncate sequence if > max_length\n    length(text_seq_inds) > max_length && (text_seq_inds = text_seq_inds[1:max_length])\n\n    # (3) pad with pad_val\n    text_seq_inds = vcat(text_seq_inds, fill(pad_val, max_length - length(text_seq_inds)))\n\n    return text_seq_inds\nend","category":"page"},{"location":"extended_examples/spam_detection/notebook/#Preparing-Data","page":"Spam Detection with RNNs","title":"Preparing Data","text":"","category":"section"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Splitting the data","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"x_data, y_data = unpack(df, ==(:Message), ==(:Category))\ny_data = coerce(y_data, Multiclass);\n\n(x_train, x_val), (y_train, y_val) = partition(\n    (x_data, y_data),\n    0.8,\n    multi = true,\n    shuffle = true,\n    rng = 42,\n);\nnothing #hide","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Now let's process the training and validation sets:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"x_train_processed = [preprocess_text(text) for text in x_train]\nx_val_processed = [preprocess_text(text) for text in x_val];\nnothing #hide","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"sanity check","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"println(x_train_processed[1], \" is \", y_data[1])","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Define the vocabulary from the training data","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"vocab = unique(vcat(x_train_processed...))\nvocab_dict = Dict(word => idx for (idx, word) in enumerate(vocab))\nvocab_size = length(vocab)\npad_val, oov_val = vocab_size + 1, vocab_size + 2\nmax_length = 12                 # can choose this more smartly if you wish","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Encode and equalize training and validation data:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"x_train_processed_equalized = [\n    encode_and_equalize(seq, vocab_dict, max_length, pad_val, oov_val) for\n        seq in x_train_processed\n        ]\nx_val_processed_equalized = [\n    encode_and_equalize(seq, vocab_dict, max_length, pad_val, oov_val) for\n        seq in x_val_processed\n        ]\nx_train_processed_equalized[1:5]        # all sequences are encoded and of the same length","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Convert both structures into matrix form:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"matrixify(v) = reduce(hcat, v)'\nx_train_processed_equalized_fixed = matrixify(x_train_processed_equalized)\nx_val_processed_equalized_fixed = matrixify(x_val_processed_equalized)\nsize(x_train_processed_equalized_fixed)","category":"page"},{"location":"extended_examples/spam_detection/notebook/#Instantiate-Model","page":"Spam Detection with RNNs","title":"Instantiate Model","text":"","category":"section"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"For the model, we will use a RNN from Flux. We will average the hidden states corresponding to any sequence then pass that to a dense layer for classification.","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"For this, we need to define a custom Flux layer to perform the averaging operation:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"struct Mean end\nFlux.@layer Mean\n(m::Mean)(x) = mean(x, dims = 2)[:, 1, :]   # [batch_size, seq_len, hidden_dim] => [batch_size, 1, hidden_dim]=> [batch_size, hidden_dim]","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"For compatibility, we will also define a layer that simply casts the input to integers as the embedding layer in Flux expects integers but the MLJFlux model expects floats:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"struct Intify end\nFlux.@layer Intify\n(m::Intify)(x) = Int.(x)","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Here we define our network:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"builder = MLJFlux.@builder begin\n    Chain(\n        Intify(),                         # Cast input to integer\n        Embedding(vocab_size + 2 => 300), # Embedding layer\n        RNN(300, 50, tanh),               # RNN layer\n        Mean(),                           # Mean pooling layer\n        Dense(50, 2),                     # Classification dense layer\n    )\nend","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Notice that we used an embedding layer with input dimensionality vocab_size + 2 to take into account the padding and out-of-vocabulary tokens. Recall that the indices in our input correspond to one-hot-vectors and the embedding layer's purpose is to learn to map them into meaningful dense vectors (of dimensionality 300 here).","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Load and instantiate model","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg = MLJFlux\nclf = NeuralNetworkClassifier(\n    builder = builder,\n    optimiser = Optimisers.Adam(0.1),\n    batch_size = 128,\n    epochs = 10,\n)","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Wrap it in a machine","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"x_train_processed_equalized_fixed = coerce(x_train_processed_equalized_fixed, Continuous)\nmach = machine(clf, x_train_processed_equalized_fixed, y_train)","category":"page"},{"location":"extended_examples/spam_detection/notebook/#Train-the-Model","page":"Spam Detection with RNNs","title":"Train the Model","text":"","category":"section"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"fit!(mach)","category":"page"},{"location":"extended_examples/spam_detection/notebook/#Evaluate-the-Model","page":"Spam Detection with RNNs","title":"Evaluate the Model","text":"","category":"section"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"ŷ = predict_mode(mach, x_val_processed_equalized_fixed)\nbalanced_accuracy(ŷ, y_val)","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"Acceptable performance. Let's see some live examples:","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"using Random: Random;\nRandom.seed!(99);\n\nz = rand(x_val)\nz_processed = preprocess_text(z)\nz_encoded_equalized =\n    encode_and_equalize(z_processed, vocab_dict, max_length, pad_val, oov_val)\nz_encoded_equalized_fixed = matrixify([z_encoded_equalized])\nz_encoded_equalized_fixed = coerce(z_encoded_equalized_fixed, Continuous)\nz_pred = predict_mode(mach, z_encoded_equalized_fixed)\n\nprint(\"SMS: `$(z)` and the prediction is `$(z_pred)`\")","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"","category":"page"},{"location":"extended_examples/spam_detection/notebook/","page":"Spam Detection with RNNs","title":"Spam Detection with RNNs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"common_workflows/composition/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"common_workflows/composition/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"common_workflows/composition/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"common_workflows/composition/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"common_workflows/incremental_training/notebook/#Incremental-Training-with-MLJFlux","page":"Incremental Training","title":"Incremental Training with MLJFlux","text":"","category":"section"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"This demonstration is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"In this workflow example we explore how to incrementally train MLJFlux models.","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"common_workflows/incremental_training/notebook/#Basic-Imports","page":"Incremental Training","title":"Basic Imports","text":"","category":"section"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nimport Optimisers       # native Flux.jl optimisers no longer supported","category":"page"},{"location":"common_workflows/incremental_training/notebook/#Loading-and-Splitting-the-Data","page":"Incremental Training","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng=123);\nX = Float32.(X)      # To be compatible with type of network network parameters\n(X_train, X_test), (y_train, y_test) = partition(\n    (X, y), 0.8,\n    multi = true,\n    shuffle = true,\n    rng=42,\n);\nnothing #hide","category":"page"},{"location":"common_workflows/incremental_training/notebook/#Instantiating-the-model","page":"Incremental Training","title":"Instantiating the model","text":"","category":"section"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"Now let's construct our model. This follows a similar setup to the one followed in the Quick Start.","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Optimisers.Adam(0.01),\n    batch_size=8,\n    epochs=10,\n    rng=42,\n)","category":"page"},{"location":"common_workflows/incremental_training/notebook/#Initial-round-of-training","page":"Incremental Training","title":"Initial round of training","text":"","category":"section"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"Now let's train the model. Calling fit! will automatically train it for 100 epochs as specified above.","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"mach = machine(clf, X_train, y_train)\nfit!(mach)","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"Let's evaluate the training loss and validation accuracy","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"training_loss = cross_entropy(predict(mach, X_train), y_train)","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"val_acc = accuracy(predict_mode(mach, X_test), y_test)","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"Poor performance it seems.","category":"page"},{"location":"common_workflows/incremental_training/notebook/#Incremental-Training","page":"Incremental Training","title":"Incremental Training","text":"","category":"section"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"Now let's train it for another 30 epochs at half the original learning rate. All we need to do is changes these hyperparameters and call fit again. It won't reset the model parameters before training.","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"clf.optimiser = Optimisers.Adam(clf.optimiser.eta/2)\nclf.epochs = clf.epochs + 30\nfit!(mach, verbosity=2);\nnothing #hide","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"Let's evaluate the training loss and validation accuracy","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"training_loss = cross_entropy(predict(mach, X_train), y_train)","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"training_acc = accuracy(predict_mode(mach, X_test), y_test)","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"That's much better. If we are rather interested in resetting the model parameters before fitting, we can do fit(mach, force=true).","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"","category":"page"},{"location":"common_workflows/incremental_training/notebook/","page":"Incremental Training","title":"Incremental Training","text":"This page was generated using Literate.jl.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"extended_examples/MNIST/notebook/#Using-MLJ-to-classifiy-the-MNIST-image-dataset","page":"MNIST Images","title":"Using MLJ to classifiy the MNIST image dataset","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"This tutorial is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"using MLJ\nusing Flux\nimport MLJFlux\nimport MLUtils\nimport MLJIteration # for `skip`","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"If running on a GPU, you will also need to import CUDA and import cuDNN.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"using Plots\ngr(size=(600, 300*(sqrt(5)-1)));\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/#Basic-training","page":"MNIST Images","title":"Basic training","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Downloading the MNIST image dataset:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"import MLDatasets: MNIST\n\nENV[\"DATADEPS_ALWAYS_ACCEPT\"] = true\nimages, labels = MNIST(split=:train)[:];\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"In MLJ, integers cannot be used for encoding categorical data, so we must force the labels to have the Multiclass scientific type. For more on this, see Working with Categorical Data.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"labels = coerce(labels, Multiclass);\nimages = coerce(images, GrayImage);\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Checking scientific types:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"@assert scitype(images) <: AbstractVector{<:Image}\n@assert scitype(labels) <: AbstractVector{<:Finite}","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Looks good.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"For general instructions on coercing image data, see Type coercion for image data","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"images[1]","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"We start by defining a suitable Builder object. This is a recipe for building the neural network. Our builder will work for images of any (constant) size, whether they be color or black and white (ie, single or multi-channel).  The architecture always consists of six alternating convolution and max-pool layers, and a final dense layer; the filter size and the number of channels after each convolution layer is customisable.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"import MLJFlux\nstruct MyConvBuilder\n    filter_size::Int\n    channels1::Int\n    channels2::Int\n    channels3::Int\nend\n\nfunction MLJFlux.build(b::MyConvBuilder, rng, n_in, n_out, n_channels)\n    k, c1, c2, c3 = b.filter_size, b.channels1, b.channels2, b.channels3\n    mod(k, 2) == 1 || error(\"`filter_size` must be odd. \")\n    p = div(k - 1, 2) # padding to preserve image size\n    init = Flux.glorot_uniform(rng)\n    front = Chain(\n        Conv((k, k), n_channels => c1, pad=(p, p), relu, init=init),\n        MaxPool((2, 2)),\n        Conv((k, k), c1 => c2, pad=(p, p), relu, init=init),\n        MaxPool((2, 2)),\n        Conv((k, k), c2 => c3, pad=(p, p), relu, init=init),\n        MaxPool((2 ,2)),\n        MLUtils.flatten)\n    d = Flux.outputsize(front, (n_in..., n_channels, 1)) |> first\n    return Chain(front, Dense(d, n_out, init=init))\nend","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Notes.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"There is no final softmax here, as this is applied by default in all MLJFLux classifiers. Customisation of this behaviour is controlled using using the finaliser hyperparameter of the classifier.\nInstead of calculating the padding p, Flux can infer the required padding in each dimension, which you enable by replacing pad = (p, p) with pad = SamePad().","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"We now define the MLJ model.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"ImageClassifier = @load ImageClassifier\nclf = ImageClassifier(\n    builder=MyConvBuilder(3, 16, 32, 32),\n    batch_size=50,\n    epochs=10,\n    rng=123,\n)","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"You can add Flux options optimiser=... and loss=... in the above constructor call. At present, loss must be a Flux-compatible loss, not an MLJ measure. To run on a GPU, add to the constructor acceleration=CUDALib() and omit rng.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"For illustration purposes, we won't use all the data here:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"train = 1:500\ntest = 501:1000","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Binding the model with data in an MLJ machine:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"mach = machine(clf, images, labels);\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Training for 10 epochs on the first 500 images:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"fit!(mach, rows=train, verbosity=2);\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Inspecting:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"report(mach)","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"chain = fitted_params(mach)","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Flux.params(chain)[2]","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Adding 20 more epochs:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"clf.epochs = clf.epochs + 20\nfit!(mach, rows=train);\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Computing an out-of-sample estimate of the loss:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"predicted_labels = predict(mach, rows=test);\ncross_entropy(predicted_labels, labels[test])","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Or to fit and predict, in one line:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"evaluate!(mach,\n          resampling=Holdout(fraction_train=0.5),\n          measure=cross_entropy,\n          rows=1:1000,\n          verbosity=0)","category":"page"},{"location":"extended_examples/MNIST/notebook/#Wrapping-the-MLJFlux-model-with-iteration-controls","page":"MNIST Images","title":"Wrapping the MLJFlux model with iteration controls","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Any iterative MLJFlux model can be wrapped in iteration controls, as we demonstrate next. For more on MLJ's IteratedModel wrapper, see the MLJ documentation.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"The \"self-iterating\" classifier, called iterated_clf below, is for iterating the image classifier defined above until one of the following stopping criterion apply:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Patience(3): 3 consecutive increases in the loss\nInvalidValue(): an out-of-sample loss, or a training loss, is NaN, Inf, or -Inf\nTimeLimit(t=5/60): training time has exceeded 5 minutes","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"These checks (and other controls) will be applied every two epochs (because of the Step(2) control). Additionally, training a machine bound to iterated_clf will:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"save a snapshot of the machine every three control cycles (every six epochs)\nrecord traces of the out-of-sample loss and training losses for plotting\nrecord mean value traces of each Flux parameter for plotting","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"For a complete list of controls, see this table.","category":"page"},{"location":"extended_examples/MNIST/notebook/#Wrapping-the-classifier","page":"MNIST Images","title":"Wrapping the classifier","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Some helpers","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"To extract Flux params from an MLJFlux machine","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"parameters(mach) = vec.(Flux.params(fitted_params(mach)));\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"To store the traces:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"losses = []\ntraining_losses = []\nparameter_means = Float32[];\nepochs = []","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"To update the traces:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"update_loss(loss) = push!(losses, loss)\nupdate_training_loss(losses) = push!(training_losses, losses[end])\nupdate_means(mach) = append!(parameter_means, mean.(parameters(mach)));\nupdate_epochs(epoch) = push!(epochs, epoch)","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"The controls to apply:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"save_control =\n    MLJIteration.skip(Save(joinpath(tempdir(), \"mnist.jls\")), predicate=3)\n\ncontrols=[\n    Step(2),\n    Patience(3),\n    InvalidValue(),\n    TimeLimit(5/60),\n    save_control,\n    WithLossDo(),\n    WithLossDo(update_loss),\n    WithTrainingLossesDo(update_training_loss),\n    Callback(update_means),\n    WithIterationsDo(update_epochs),\n];\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"The \"self-iterating\" classifier:","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"iterated_clf = IteratedModel(\n    clf,\n    controls=controls,\n    resampling=Holdout(fraction_train=0.7),\n    measure=log_loss,\n)","category":"page"},{"location":"extended_examples/MNIST/notebook/#Binding-the-wrapped-model-to-data:","page":"MNIST Images","title":"Binding the wrapped model to data:","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"mach = machine(iterated_clf, images, labels);\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/#Training","page":"MNIST Images","title":"Training","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"fit!(mach, rows=train);\nnothing #hide","category":"page"},{"location":"extended_examples/MNIST/notebook/#Comparison-of-the-training-and-out-of-sample-losses:","page":"MNIST Images","title":"Comparison of the training and out-of-sample losses:","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"plot(\n    epochs,\n    losses,\n    xlab = \"epoch\",\n    ylab = \"cross entropy\",\n    label=\"out-of-sample\",\n)\nplot!(epochs, training_losses, label=\"training\")\n\nsavefig(joinpath(tempdir(), \"loss.png\"))","category":"page"},{"location":"extended_examples/MNIST/notebook/#Evolution-of-weights","page":"MNIST Images","title":"Evolution of weights","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"n_epochs =  length(losses)\nn_parameters = div(length(parameter_means), n_epochs)\nparameter_means2 = reshape(copy(parameter_means), n_parameters, n_epochs)'\nplot(\n    epochs,\n    parameter_means2,\n    title=\"Flux parameter mean weights\",\n    xlab = \"epoch\",\n)","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Note. The higher the number in the plot legend, the deeper the layer we are **weight-averaging.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"savefig(joinpath(tempdir(), \"weights.png\"))","category":"page"},{"location":"extended_examples/MNIST/notebook/#Retrieving-a-snapshot-for-a-prediction:","page":"MNIST Images","title":"Retrieving a snapshot for a prediction:","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"mach2 = machine(joinpath(tempdir(), \"mnist3.jls\"))\npredict_mode(mach2, images[501:503])","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"3-element CategoricalArrays.CategoricalArray{Int64,1,UInt32}:\n 7\n 9\n 5","category":"page"},{"location":"extended_examples/MNIST/notebook/#Restarting-training","page":"MNIST Images","title":"Restarting training","text":"","category":"section"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"Mutating iterated_clf.controls or clf.epochs (which is otherwise ignored) will allow you to restart training from where it left off.","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"iterated_clf.controls[2] = Patience(4)\nfit!(mach, rows=train)\n\nplot(\n    epochs,\n    losses,\n    xlab = \"epoch\",\n    ylab = \"cross entropy\",\n    label=\"out-of-sample\",\n)\nplot!(epochs, training_losses, label=\"training\")","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"","category":"page"},{"location":"extended_examples/MNIST/notebook/","page":"MNIST Images","title":"MNIST Images","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/Multitarget Regression/","page":"Multi-Target Regression","title":"Multi-Target Regression","text":"MLJFlux.MultitargetNeuralNetworkRegressor","category":"page"},{"location":"interface/Multitarget Regression/#MLJFlux.MultitargetNeuralNetworkRegressor","page":"Multi-Target Regression","title":"MLJFlux.MultitargetNeuralNetworkRegressor","text":"MultitargetNeuralNetworkRegressor\n\nA model type for constructing a multitarget neural network regressor, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nMultitargetNeuralNetworkRegressor = @load MultitargetNeuralNetworkRegressor pkg=MLJFlux\n\nDo model = MultitargetNeuralNetworkRegressor() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in MultitargetNeuralNetworkRegressor(builder=...).\n\nMultitargetNeuralNetworkRegressor is for training a data-dependent Flux.jl neural network to predict a multi-valued Continuous target, represented as a table, given a table of Continuous features. Users provide a recipe for constructing the network, based on properties of the data that is encountered, by specifying an appropriate builder. See MLJFlux documentation for more on builders.\n\nIn addition to features with Continuous scientific element type, this model supports categorical features in the input table. If present, such features are embedded into dense vectors by the use of an additional EntityEmbedder layer after the input, as described in Entity Embeddings of Categorical Variables by Cheng Guo, Felix Berkhahn arXiv, 2016.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX provides input features and is either: (i) a Matrix with Continuous element scitype (typically Float32); or (ii) a table of input features (eg, a DataFrame) whose columns have Continuous, Multiclass or OrderedFactor element scitype; check column scitypes with schema(X).  If any Multiclass or OrderedFactor features appear, the constructed network will use an EntityEmbedder layer to transform them into dense vectors. If X is a Matrix, it is assumed that columns correspond to features and rows corresponding to observations.\n\ny is the target, which can be any table or matrix of output targets whose element scitype is Continuous; check column scitypes with schema(y). If y is a Matrix, it is assumed to have columns corresponding to variables and rows corresponding to observations.\n\nHyper-parameters\n\nbuilder=MLJFlux.Linear(σ=Flux.relu): An MLJFlux builder that constructs a neural network. Possible builders include: Linear, Short, and MLP. See MLJFlux documentation for more on builders, and the example below for using the @builder convenience macro.\noptimiser::Optimisers.Adam(): An Optimisers.jl optimiser. The optimiser performs the updating of the weights of the network. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.mse: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a regression task, natural loss functions are:\nFlux.mse\nFlux.mae\nFlux.msle\nFlux.huber_loss\nCurrently MLJ measures are not supported as loss functions here.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights. Typically, batch size is between 8 and 512. Increassing batch size may accelerate training if acceleration=CUDALibs() and a GPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞). Note the history reports unpenalized losses.\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training. The default is Random.default_rng().\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\nembedding_dims: a Dict whose keys are names of categorical features, given as symbols, and whose values are numbers representing the desired dimensionality of the entity embeddings of such features: an integer value of 7, say, sets the embedding dimensionality to 7; a float value of 0.5, say, sets the embedding dimensionality to ceil(0.5 * c), where c is the number of feature levels.  Unspecified feature dimensionality defaults to min(c - 1, 10).\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew having the same scitype as X above. Predictions are deterministic.\ntransform(mach, Xnew): Assuming Xnew has the same schema as X, transform the categorical features of Xnew into dense Continuous vectors using the MLJFlux.EntityEmbedder layer present in the network. Does nothing in case the model was trained on an input X that lacks categorical features.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers,  functions, and activations  which make up the neural network.\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalised if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we apply a multi-target regression model to synthetic data:\n\nusing MLJ\nimport MLJFlux\nusing Flux\nimport Optimisers\n\nFirst, we generate some synthetic data (needs MLJBase 0.20.16 or higher):\n\nX, y = make_regression(100, 9; n_targets = 2) # both tables\nschema(y)\nschema(X)\n\nSplitting off a test set:\n\n(X, Xtest), (y, ytest) = partition((X, y), 0.7, multi=true);\n\nNext, we can define a builder, making use of a convenience macro to do so.  In the following @builder call, n_in is a proxy for the number input features and n_out the number of target variables (both known at fit! time), while rng is a proxy for a RNG (which will be passed from the rng field of model defined below).\n\nbuilder = MLJFlux.@builder begin\n    init=Flux.glorot_uniform(rng)\n    Chain(\n        Dense(n_in, 64, relu, init=init),\n        Dense(64, 32, relu, init=init),\n        Dense(32, n_out, init=init),\n    )\nend\n\nInstantiating the regression model:\n\nMultitargetNeuralNetworkRegressor = @load MultitargetNeuralNetworkRegressor\nmodel = MultitargetNeuralNetworkRegressor(builder=builder, rng=123, epochs=20)\n\nWe will arrange for standardization of the the target by wrapping our model in  TransformedTargetModel, and standardization of the features by inserting the wrapped  model in a pipeline:\n\npipe = Standardizer |> TransformedTargetModel(model, transformer=Standardizer)\n\nIf we fit with a high verbosity (>1), we will see the losses during training. We can also see the losses in the output of report(mach)\n\nmach = machine(pipe, X, y)\nfit!(mach, verbosity=2)\n\n# first element initial loss, 2:end per epoch training losses\nreport(mach).transformed_target_model_deterministic.model.training_losses\n\nFor experimenting with learning rate, see the NeuralNetworkRegressor example.\n\npipe.transformed_target_model_deterministic.model.optimiser = Optimisers.Adam(0.0001)\n\nWith the learning rate fixed, we can now compute a CV estimate of the performance (using all data bound to mach) and compare this with performance on the test set:\n\n\n# CV estimate, based on `(X, y)`:\nevaluate!(mach, resampling=CV(nfolds=5), measure=multitarget_l2)\n\n# loss for `(Xtest, test)`:\nfit!(mach) # trains on all data `(X, y)`\nyhat = predict(mach, Xtest)\nmultitarget_l2(yhat, ytest)\n\nSee also NeuralNetworkRegressor\n\n\n\n\n\n","category":"type"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"common_workflows/early_stopping/notebook/#Early-Stopping-with-MLJ","page":"Early Stopping","title":"Early Stopping with MLJ","text":"","category":"section"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"This demonstration is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"In this workflow example, we learn how MLJFlux enables us to easily use early stopping when training MLJFlux models.","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"common_workflows/early_stopping/notebook/#Basic-Imports","page":"Early Stopping","title":"Basic Imports","text":"","category":"section"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nusing Plots             # To visualize training\nimport Optimisers       # native Flux.jl optimisers no longer supported","category":"page"},{"location":"common_workflows/early_stopping/notebook/#Loading-and-Splitting-the-Data","page":"Early Stopping","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng=123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nnothing #hide","category":"page"},{"location":"common_workflows/early_stopping/notebook/#Instantiating-the-model-Now-let's-construct-our-model.-This-follows-a-similar-setup","page":"Early Stopping","title":"Instantiating the model Now let's construct our model. This follows a similar setup","text":"","category":"section"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"to the one followed in the Quick Start.","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Optimisers.Adam(0.01),\n    batch_size=8,\n    epochs=50,\n    rng=42,\n)","category":"page"},{"location":"common_workflows/early_stopping/notebook/#Wrapping-it-in-an-IteratedModel","page":"Early Stopping","title":"Wrapping it in an IteratedModel","text":"","category":"section"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"Let's start by defining the condition that can cause the model to early stop.","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"stop_conditions = [\n    Step(1),            # Repeatedly train for one iteration\n    NumberLimit(100),   # Don't train for more than 100 iterations\n    Patience(5),        # Stop after 5 iterations of disimprovement in validation loss\n    NumberSinceBest(9), # Or if the best loss occurred 9 iterations ago\n    TimeLimit(30/60),   # Or if 30 minutes passed\n]","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"We can also define callbacks. Here we want to store the validation loss for each iteration","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"validation_losses = []\ncallbacks = [\n    WithLossDo(loss->push!(validation_losses, loss)),\n]","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"Construct the iterated model and pass to it the stop_conditions and the callbacks:","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"iterated_model = IteratedModel(\n    model=clf,\n    resampling=Holdout(fraction_train=0.7); # loss and stopping are based on out-of-sample\n    measures=log_loss,\n    iteration_parameter=:(epochs),\n    controls=vcat(stop_conditions, callbacks),\n    retrain=false            # no need to retrain on all data at the end\n);\nnothing #hide","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"You can see more advanced stopping conditions as well as how to involve callbacks in the documentation","category":"page"},{"location":"common_workflows/early_stopping/notebook/#Training-with-Early-Stopping","page":"Early Stopping","title":"Training with Early Stopping","text":"","category":"section"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"At this point, all we need is to fit the model and iteration controls will be automatically handled","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"mach = machine(iterated_model, X, y)\nfit!(mach)\n# We can get the training losses like so\ntraining_losses = report(mach)[:model_report].training_losses;\nnothing #hide","category":"page"},{"location":"common_workflows/early_stopping/notebook/#Results","page":"Early Stopping","title":"Results","text":"","category":"section"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"We can see that the model converged after 100 iterations.","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"plot(training_losses, label=\"Training Loss\", linewidth=2)\nplot!(validation_losses, label=\"Validation Loss\", linewidth=2, size=(800,400))","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"","category":"page"},{"location":"common_workflows/early_stopping/notebook/","page":"Early Stopping","title":"Early Stopping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"common_workflows/early_stopping/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"common_workflows/early_stopping/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"common_workflows/early_stopping/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"common_workflows/early_stopping/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"extended_examples/spam_detection/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"extended_examples/spam_detection/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"extended_examples/spam_detection/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"extended_examples/spam_detection/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"common_workflows/live_training/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"common_workflows/live_training/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"common_workflows/live_training/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"common_workflows/live_training/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"common_workflows/hyperparameter_tuning/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"common_workflows/hyperparameter_tuning/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"common_workflows/hyperparameter_tuning/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"common_workflows/hyperparameter_tuning/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"extended_examples/MNIST/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"extended_examples/MNIST/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"extended_examples/MNIST/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"extended_examples/MNIST/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"common_workflows/composition/notebook/#Model-Composition-with-MLJFlux","page":"Model Composition","title":"Model Composition with MLJFlux","text":"","category":"section"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"This demonstration is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"In this workflow example, we see how MLJFlux enables composing MLJ models with MLJFlux models. We will assume a class imbalance setting and wrap an oversampler with a deep learning model from MLJFlux.","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"common_workflows/composition/notebook/#Basic-Imports","page":"Model Composition","title":"Basic Imports","text":"","category":"section"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nimport RDatasets        # Dataset source\nimport Random           # To create imbalance\nimport Imbalance        # To solve the imbalance\nimport Optimisers       # native Flux.jl optimisers no longer supported","category":"page"},{"location":"common_workflows/composition/notebook/#Loading-and-Splitting-the-Data","page":"Model Composition","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng=123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nnothing #hide","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"To simulate an imbalanced dataset, we will take a random sample:","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"Random.seed!(803429)\nsubset_indices = rand(1:size(X, 1), 100)\nX, y = X[subset_indices, :], y[subset_indices]\nImbalance.checkbalance(y)","category":"page"},{"location":"common_workflows/composition/notebook/#Instantiating-the-model","page":"Model Composition","title":"Instantiating the model","text":"","category":"section"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"Let's load BorderlineSMOTE1 to oversample the data and Standardizer to standardize it.","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"BorderlineSMOTE1 = @load BorderlineSMOTE1 pkg=Imbalance verbosity=0\nNeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"We didn't need to load Standardizer because it is a local model for MLJ (see localmodels())","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"clf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Optimisers.Adam(0.01),\n    batch_size=8,\n    epochs=50,\n    rng=42,\n)","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"First we wrap the oversampler with the neural network via the BalancedModel construct. This comes from MLJBalancing And allows combining resampling methods with MLJ models in a sequential pipeline.","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"oversampler = BorderlineSMOTE1(k=5, ratios=1.0, rng=42)\nbalanced_model = BalancedModel(model=clf, balancer1=oversampler)\nstandarizer = Standardizer()","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"Now let's compose the balanced model with a standardizer.","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"pipeline = standarizer |> balanced_model","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"By this, any training data will be standardized then oversampled then passed to the model. Meanwhile, for inference, the standardizer will automatically use the training set's mean and std and the oversampler will be transparent.","category":"page"},{"location":"common_workflows/composition/notebook/#Training-the-Composed-Model","page":"Model Composition","title":"Training the Composed Model","text":"","category":"section"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"It's indistinguishable from training a single model.","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"mach = machine(pipeline, X, y)\nfit!(mach)\ncv=CV(nfolds=5)\nevaluate!(mach, resampling=cv, measure=accuracy)","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"","category":"page"},{"location":"common_workflows/composition/notebook/","page":"Model Composition","title":"Model Composition","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/Regression/","page":"Regression","title":"Regression","text":"MLJFlux.NeuralNetworkRegressor","category":"page"},{"location":"interface/Regression/#MLJFlux.NeuralNetworkRegressor","page":"Regression","title":"MLJFlux.NeuralNetworkRegressor","text":"NeuralNetworkRegressor\n\nA model type for constructing a neural network regressor, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nNeuralNetworkRegressor = @load NeuralNetworkRegressor pkg=MLJFlux\n\nDo model = NeuralNetworkRegressor() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in NeuralNetworkRegressor(builder=...).\n\nNeuralNetworkRegressor is for training a data-dependent Flux.jl neural network to predict a Continuous target, given a table of Continuous features. Users provide a recipe for constructing the network, based on properties of the data that is encountered, by specifying an appropriate builder. See MLJFlux documentation for more on builders.\n\nIn addition to features with Continuous scientific element type, this model supports categorical features in the input table. If present, such features are embedded into dense vectors by the use of an additional EntityEmbedder layer after the input, as described in Entity Embeddings of Categorical Variables by Cheng Guo, Felix Berkhahn arXiv, 2016.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX provides input features and is either: (i) a Matrix with Continuous element scitype (typically Float32); or (ii) a table of input features (eg, a DataFrame) whose columns have Continuous, Multiclass or OrderedFactor element scitype; check column scitypes with schema(X).  If any Multiclass or OrderedFactor features appear, the constructed network will use an EntityEmbedder layer to transform them into dense vectors. If X is a Matrix, it is assumed that columns correspond to features and rows corresponding to observations.\n\ny is the target, which can be any AbstractVector whose element scitype is Continuous; check the scitype with scitype(y)\n\nTrain the machine with fit!(mach, rows=...).\n\nHyper-parameters\n\nbuilder=MLJFlux.Linear(σ=Flux.relu): An MLJFlux builder that constructs a neural  network. Possible builders include: MLJFlux.Linear, MLJFlux.Short, and  MLJFlux.MLP. See MLJFlux documentation for more on builders, and the example below  for using the @builder convenience macro.\noptimiser::Optimisers.Adam(): An Optimisers.jl optimiser. The optimiser performs the updating of the weights of the network. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.mse: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a regression task, natural loss functions are:\nFlux.mse\nFlux.mae\nFlux.msle\nFlux.huber_loss\nCurrently MLJ measures are not supported as loss functions here.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights. Typically, batch size is between 8 and 512. Increasing batch size may accelerate training if acceleration=CUDALibs() and a GPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞). Note the history reports unpenalized losses.\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training. The default is Random.default_rng().\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\nembedding_dims: a Dict whose keys are names of categorical features, given as symbols, and whose values are numbers representing the desired dimensionality of the entity embeddings of such features: an integer value of 7, say, sets the embedding dimensionality to 7; a float value of 0.5, say, sets the embedding dimensionality to ceil(0.5 * c), where c is the number of feature levels.  Unspecified feature dimensionality defaults to min(c - 1, 10).\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew, which should have the same scitype as X above.\ntransform(mach, Xnew): Assuming Xnew has the same schema as X, transform the categorical features of Xnew into dense Continuous vectors using the MLJFlux.EntityEmbedder layer present in the network. Does nothing in case the model was trained on an input X that lacks categorical features.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers, functions,  and activations which make up the neural network.\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalized if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we build a regression model for the Boston house price dataset.\n\nusing MLJ\nimport MLJFlux\nusing Flux\nimport Optimisers\n\nFirst, we load in the data: The :MEDV column becomes the target vector y, and all remaining columns go into a table X, with the exception of :CHAS:\n\ndata = OpenML.load(531); # Loads from https://www.openml.org/d/531\ny, X = unpack(data, ==(:MEDV), !=(:CHAS); rng=123);\n\nscitype(y)\nschema(X)\n\nSince MLJFlux models do not handle ordered factors, we'll treat :RAD as Continuous:\n\nX = coerce(X, :RAD=>Continuous)\n\nSplitting off a test set:\n\n(X, Xtest), (y, ytest) = partition((X, y), 0.7, multi=true);\n\nNext, we can define a builder, making use of a convenience macro to do so.  In the following @builder call, n_in is a proxy for the number input features (which will be known at fit! time) and rng is a proxy for a RNG (which will be passed from the rng field of model defined below). We also have the parameter n_out which is the number of output features. As we are doing single target regression, the value passed will always be 1, but the builder we define will also work for MultitargetNeuralNetworkRegressor.\n\nbuilder = MLJFlux.@builder begin\n    init=Flux.glorot_uniform(rng)\n    Chain(\n        Dense(n_in, 64, relu, init=init),\n        Dense(64, 32, relu, init=init),\n        Dense(32, n_out, init=init),\n    )\nend\n\nInstantiating a model:\n\nNeuralNetworkRegressor = @load NeuralNetworkRegressor pkg=MLJFlux\nmodel = NeuralNetworkRegressor(\n    builder=builder,\n    rng=123,\n    epochs=20\n)\n\nWe arrange for standardization of the the target by wrapping our model in TransformedTargetModel, and standardization of the features by inserting the wrapped model in a pipeline:\n\npipe = Standardizer |> TransformedTargetModel(model, transformer=Standardizer)\n\nIf we fit with a high verbosity (>1), we will see the losses during training. We can also see the losses in the output of report(mach).\n\nmach = machine(pipe, X, y)\nfit!(mach, verbosity=2)\n\n# first element initial loss, 2:end per epoch training losses\nreport(mach).transformed_target_model_deterministic.model.training_losses\n\nExperimenting with learning rate\n\nWe can visually compare how the learning rate affects the predictions:\n\nusing Plots\n\nrates = rates = [5e-5, 1e-4, 0.005, 0.001, 0.05]\nplt=plot()\n\nforeach(rates) do η\n  pipe.transformed_target_model_deterministic.model.optimiser = Optimisers.Adam(η)\n  fit!(mach, force=true, verbosity=0)\n  losses =\n      report(mach).transformed_target_model_deterministic.model.training_losses[3:end]\n  plot!(1:length(losses), losses, label=η)\nend\n\nplt\n\npipe.transformed_target_model_deterministic.model.optimiser.eta = Optimisers.Adam(0.0001)\n\nWith the learning rate fixed, we compute a CV estimate of the performance (using all data bound to mach) and compare this with performance on the test set:\n\n# CV estimate, based on `(X, y)`:\nevaluate!(mach, resampling=CV(nfolds=5), measure=l2)\n\n# loss for `(Xtest, test)`:\nfit!(mach) # train on `(X, y)`\nyhat = predict(mach, Xtest)\nl2(yhat, ytest)\n\nThese losses, for the pipeline model, refer to the target on the original, unstandardized, scale.\n\nFor implementing stopping criterion and other iteration controls, refer to examples linked from the MLJFlux documentation.\n\nSee also MultitargetNeuralNetworkRegressor\n\n\n\n\n\n","category":"type"},{"location":"common_workflows/comparison/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"common_workflows/comparison/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"common_workflows/comparison/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"common_workflows/comparison/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"interface/Builders/","page":"Builders","title":"Builders","text":"MLJFlux.Linear","category":"page"},{"location":"interface/Builders/#MLJFlux.Linear","page":"Builders","title":"MLJFlux.Linear","text":"Linear(; σ=Flux.relu)\n\nMLJFlux builder that constructs a fully connected two layer network with activation function σ. The number of input and output nodes is determined from the data. Weights are initialized using Flux.glorot_uniform(rng), where rng is inferred from the rng field of the MLJFlux model.\n\n\n\n\n\n","category":"type"},{"location":"interface/Builders/","page":"Builders","title":"Builders","text":"MLJFlux.Short","category":"page"},{"location":"interface/Builders/#MLJFlux.Short","page":"Builders","title":"MLJFlux.Short","text":"Short(; n_hidden=0, dropout=0.5, σ=Flux.sigmoid)\n\nMLJFlux builder that constructs a full-connected three-layer network using n_hidden nodes in the hidden layer and the specified dropout (defaulting to 0.5). An activation function σ is applied between the hidden and final layers. If n_hidden=0 (the default) then n_hidden is the geometric mean of the number of input and output nodes.  The number of input and output nodes is determined from the data.\n\nEach layer is initialized using Flux.glorot_uniform(rng), where rng is inferred from the rng field of the MLJFlux model.\n\n\n\n\n\n","category":"type"},{"location":"interface/Builders/","page":"Builders","title":"Builders","text":"MLJFlux.MLP","category":"page"},{"location":"interface/Builders/#MLJFlux.MLP","page":"Builders","title":"MLJFlux.MLP","text":"MLP(; hidden=(100,), σ=Flux.relu)\n\nMLJFlux builder that constructs a Multi-layer perceptron network. The ith element of hidden represents the number of neurons in the ith hidden layer. An activation function σ is applied between each layer.\n\nEach layer is initialized using Flux.glorot_uniform(rng), where rng is inferred from the rng field of the MLJFlux model.\n\n\n\n\n\n","category":"type"},{"location":"interface/Builders/","page":"Builders","title":"Builders","text":"MLJFlux.@builder","category":"page"},{"location":"interface/Builders/#MLJFlux.@builder","page":"Builders","title":"MLJFlux.@builder","text":"@builder neural_net\n\nCreates a builder for neural_net. The variables rng, n_in, n_out and n_channels can be used to create builders for any random number generator rng, input and output sizes n_in and n_out and number of input channels n_channels.\n\nExamples\n\njulia> import MLJFlux: @builder;\n\njulia> nn = NeuralNetworkRegressor(builder = @builder(Chain(Dense(n_in, 64, relu),\n                                                            Dense(64, 32, relu),\n                                                            Dense(32, n_out))));\n\njulia> conv_builder = @builder begin\n           front = Chain(Conv((3, 3), n_channels => 16), Flux.flatten)\n           d = Flux.outputsize(front, (n_in..., n_channels, 1)) |> first\n           Chain(front, Dense(d, n_out));\n       end\n\njulia> conv_nn = NeuralNetworkRegressor(builder = conv_builder);\n\n\n\n\n\n","category":"macro"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"common_workflows/architecture_search/notebook/#Neural-Architecture-Search-with-MLJFlux","page":"Neural Architecture Search","title":"Neural Architecture Search with MLJFlux","text":"","category":"section"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"This demonstration is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Neural Architecture Search (NAS) is an instance of hyperparameter tuning concerned with tuning model hyperparameters defining the architecture itself. Although it's typically performed with sophisticated search algorithms for efficiency, in this example we will be using a simple random search.","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"common_workflows/architecture_search/notebook/#Basic-Imports","page":"Neural Architecture Search","title":"Basic Imports","text":"","category":"section"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"using MLJ               # Has MLJFlux models\nusing Flux              # For more flexibility\nusing RDatasets: RDatasets        # Dataset source\nusing DataFrames        # To view tuning results in a table\nimport Optimisers       # native Flux.jl optimisers no longer supported","category":"page"},{"location":"common_workflows/architecture_search/notebook/#Loading-and-Splitting-the-Data","page":"Neural Architecture Search","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng = 123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nfirst(X, 5)","category":"page"},{"location":"common_workflows/architecture_search/notebook/#Instantiating-the-model","page":"Neural Architecture Search","title":"Instantiating the model","text":"","category":"section"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Now let's construct our model. This follows a similar setup the one followed in the Quick Start.","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg = \"MLJFlux\"\nclf = NeuralNetworkClassifier(\n    builder = MLJFlux.MLP(; hidden = (1, 1, 1), σ = Flux.relu),\n    optimiser = Optimisers.ADAM(0.01),\n    batch_size = 8,\n    epochs = 10,\n    rng = 42,\n)","category":"page"},{"location":"common_workflows/architecture_search/notebook/#Generating-Network-Architectures","page":"Neural Architecture Search","title":"Generating Network Architectures","text":"","category":"section"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"We know that the MLP builder takes a tuple of the form (z_1 z_2  z_k) to define a network with k hidden layers and where the ith layer has z_i neurons. We will proceed by defining a function that can generate all possible networks with a specific number of hidden layers, a minimum and maximum number of neurons per layer and increments to consider for the number of neurons.","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"function generate_networks(\n    ;min_neurons::Int,\n    max_neurons::Int,\n    neuron_step::Int,\n    num_layers::Int,\n    )\n    # Define the range of neurons\n    neuron_range = min_neurons:neuron_step:max_neurons\n\n    # Empty list to store the network configurations\n    networks = Vector{Tuple{Vararg{Int, num_layers}}}()\n\n    # Recursive helper function to generate all combinations of tuples\n    function generate_tuple(current_layers, remaining_layers)\n        if remaining_layers > 0\n            for n in neuron_range\n                # current_layers =[] then current_layers=[(min_neurons)],\n                # [(min_neurons+neuron_step)], [(min_neurons+2*neuron_step)],...\n                # for each of these we call generate_layers again which appends\n                # the n combinations for each one of them\n                generate_tuple(vcat(current_layers, [n]), remaining_layers - 1)\n            end\n        else\n            # in the base case, no more layers to \"recurse on\"\n            # and we just append the current_layers as a tuple\n            push!(networks, tuple(current_layers...))\n        end\n    end\n\n    # Generate networks for the given number of layers\n    generate_tuple([], num_layers)\n\n    return networks\nend","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Now let's generate an array of all possible neural networks with three hidden layers and number of neurons per layer ∈ [1,64] with a step of 4","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"networks_space =\n    generate_networks(\n        min_neurons = 1,\n        max_neurons = 64,\n        neuron_step = 4,\n        num_layers = 3,\n    )\n\nnetworks_space[1:5]","category":"page"},{"location":"common_workflows/architecture_search/notebook/#Wrapping-the-Model-for-Tuning","page":"Neural Architecture Search","title":"Wrapping the Model for Tuning","text":"","category":"section"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Let's use this array to define the range of hyperparameters and pass it along with the model to the TunedModel constructor.","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"r1 = range(clf, :(builder.hidden), values = networks_space)\n\ntuned_clf = TunedModel(\n    model = clf,\n    tuning = RandomSearch(),\n    resampling = CV(nfolds = 4, rng = 42),\n    range = [r1],\n    measure = cross_entropy,\n    n = 100,             # searching over 100 random samples are enough\n);\nnothing #hide","category":"page"},{"location":"common_workflows/architecture_search/notebook/#Performing-the-Search","page":"Neural Architecture Search","title":"Performing the Search","text":"","category":"section"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Similar to the last workflow example, all we need now is to fit our model and the search will take place automatically:","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"mach = machine(tuned_clf, X, y);\nfit!(mach, verbosity = 0);\nfitted_params(mach).best_model","category":"page"},{"location":"common_workflows/architecture_search/notebook/#Analyzing-the-Search-Results","page":"Neural Architecture Search","title":"Analyzing the Search Results","text":"","category":"section"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"Let's analyze the search results by converting the history array to a dataframe and viewing it:","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"history = report(mach).history\nhistory_df = DataFrame(\n    mlp = [x[:model].builder for x in history],\n    measurement = [x[:measurement][1] for x in history],\n)\nfirst(sort!(history_df, [order(:measurement)]), 10)","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"","category":"page"},{"location":"common_workflows/architecture_search/notebook/","page":"Neural Architecture Search","title":"Neural Architecture Search","text":"This page was generated using Literate.jl.","category":"page"},{"location":"interface/Image Classification/","page":"Image Classification","title":"Image Classification","text":"MLJFlux.ImageClassifier","category":"page"},{"location":"interface/Image Classification/#MLJFlux.ImageClassifier","page":"Image Classification","title":"MLJFlux.ImageClassifier","text":"ImageClassifier\n\nA model type for constructing a image classifier, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nImageClassifier = @load ImageClassifier pkg=MLJFlux\n\nDo model = ImageClassifier() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in ImageClassifier(builder=...).\n\nImageClassifier classifies images using a neural network adapted to the type of images provided (color or gray scale). Predictions are probabilistic. Users provide a recipe for constructing the network, based on properties of the image encountered, by specifying an appropriate builder. See MLJFlux documentation for more on builders.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX is any AbstractVector of images with ColorImage or GrayImage scitype; check  the scitype with scitype(X) and refer to ScientificTypes.jl documentation on coercing  typical image formats into an appropriate type.\ny is the target, which can be any AbstractVector whose element  scitype is Multiclass; check the scitype with scitype(y).\n\nTrain the machine with fit!(mach, rows=...).\n\nHyper-parameters\n\nbuilder: An MLJFlux builder that constructs the neural network.  The fallback builds a  depth-16 VGG architecture adapted to the image size and number of target classes, with  no batch normalization; see the Metalhead.jl documentation for details. See the example  below for a user-specified builder. A convenience macro @builder is also  available. See also finaliser below.\noptimiser::Optimisers.Adam(): An Optimisers.jl optimiser. The optimiser performs the updating of the weights of the network. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.crossentropy: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a classification task, the most natural loss functions are:\nFlux.crossentropy: Standard multiclass classification loss, also known as the log loss.\nFlux.logitcrossentopy: Mathematically equal to crossentropy, but numerically more stable than finalising the outputs with softmax and then calculating crossentropy. You will need to specify finaliser=identity to remove MLJFlux's default softmax finaliser, and understand that the output of predict is then unnormalized (no longer probabilistic).\nFlux.tversky_loss: Used with imbalanced data to give more weight to false negatives.\nFlux.focal_loss: Used with highly imbalanced data. Weights harder examples more than easier examples.\nCurrently MLJ measures are not supported values of loss.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights. Typically, batch size is between 8 and\nIncreassing batch size may accelerate training if acceleration=CUDALibs() and a\nGPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞). Note the history reports unpenalized losses.\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training. The default is Random.default_rng().\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\nfinaliser=Flux.softmax: The final activation function of the neural network (applied after the network defined by builder). Defaults to Flux.softmax.\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew, which should have the same scitype as X above. Predictions are probabilistic but uncalibrated.\npredict_mode(mach, Xnew): Return the modes of the probabilistic predictions returned above.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers,  functions, and activations  which make up the neural network. This includes  the final layer specified by finaliser (eg, softmax).\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalised if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we use MLJFlux and a custom builder to classify the MNIST image dataset.\n\nusing MLJ\nusing Flux\nimport MLJFlux\nimport Optimisers\nimport MLJIteration # for `skip` control\n\nFirst we want to download the MNIST dataset, and unpack into images and labels:\n\nimport MLDatasets: MNIST\ndata = MNIST(split=:train)\nimages, labels = data.features, data.targets\n\nIn MLJ, integers cannot be used for encoding categorical data, so we must coerce them into the Multiclass scitype:\n\nlabels = coerce(labels, Multiclass);\n\nAbove images is a single array but MLJFlux requires the images to be a vector of individual image arrays:\n\nimages = coerce(images, GrayImage);\nimages[1]\n\nWe start by defining a suitable builder object. This is a recipe for building the neural network. Our builder will work for images of any (constant) size, whether they be color or black and white (ie, single or multi-channel).  The architecture always consists of six alternating convolution and max-pool layers, and a final dense layer; the filter size and the number of channels after each convolution layer is customizable.\n\nimport MLJFlux\n\nstruct MyConvBuilder\n    filter_size::Int\n    channels1::Int\n    channels2::Int\n    channels3::Int\nend\n\nmake2d(x::AbstractArray) = reshape(x, :, size(x)[end])\n\nfunction MLJFlux.build(b::MyConvBuilder, rng, n_in, n_out, n_channels)\n    k, c1, c2, c3 = b.filter_size, b.channels1, b.channels2, b.channels3\n    mod(k, 2) == 1 || error(\"`filter_size` must be odd. \")\n    p = div(k - 1, 2) # padding to preserve image size\n    init = Flux.glorot_uniform(rng)\n    front = Chain(\n        Conv((k, k), n_channels => c1, pad=(p, p), relu, init=init),\n        MaxPool((2, 2)),\n        Conv((k, k), c1 => c2, pad=(p, p), relu, init=init),\n        MaxPool((2, 2)),\n        Conv((k, k), c2 => c3, pad=(p, p), relu, init=init),\n        MaxPool((2 ,2)),\n        make2d)\n    d = Flux.outputsize(front, (n_in..., n_channels, 1)) |> first\n    return Chain(front, Dense(d, n_out, init=init))\nend\n\nIt is important to note that in our build function, there is no final softmax. This is applied by default in all MLJFlux classifiers (override this using the finaliser hyperparameter).\n\nNow that our builder is defined, we can instantiate the actual MLJFlux model. If you have a GPU, you can substitute in acceleration=CUDALibs() below to speed up training.\n\nImageClassifier = @load ImageClassifier pkg=MLJFlux\nclf = ImageClassifier(builder=MyConvBuilder(3, 16, 32, 32),\n                      batch_size=50,\n                      epochs=10,\n                      rng=123)\n\nYou can add Flux options such as optimiser and loss in the snippet above. Currently, loss must be a flux-compatible loss, and not an MLJ measure.\n\nNext, we can bind the model with the data in a machine, and train using the first 500 images:\n\nmach = machine(clf, images, labels);\nfit!(mach, rows=1:500, verbosity=2);\nreport(mach)\nchain = fitted_params(mach)\nFlux.params(chain)[2]\n\nWe can tack on 20 more epochs by modifying the epochs field, and iteratively fit some more:\n\nclf.epochs = clf.epochs + 20\nfit!(mach, rows=1:500, verbosity=2);\n\nWe can also make predictions and calculate an out-of-sample loss estimate, using any MLJ measure (loss/score):\n\npredicted_labels = predict(mach, rows=501:1000);\ncross_entropy(predicted_labels, labels[501:1000])\n\nThe preceding fit!/predict/evaluate workflow can be alternatively executed as follows:\n\nevaluate!(mach,\n          resampling=Holdout(fraction_train=0.5),\n          measure=cross_entropy,\n          rows=1:1000,\n          verbosity=0)\n\nSee also NeuralNetworkClassifier.\n\n\n\n\n\n","category":"type"},{"location":"interface/Summary/#Models","page":"Summary","title":"Models","text":"","category":"section"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"MLJFlux provides the model types below, for use with input features X and targets y of the scientific type indicated in the table below. The parameters n_in, n_out and n_channels refer to information passed to the builder, as described under Defining Custom Builders.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Model Type Prediction type scitype(X) <: _ scitype(y) <: _\nNeuralNetworkRegressor Deterministic AbstractMatrix{Continuous} or Table(Continuous) with n_in columns AbstractVector{<:Continuous) (n_out = 1)\nMultitargetNeuralNetworkRegressor Deterministic AbstractMatrix{Continuous} or Table(Continuous) with n_in columns <: Table(Continuous) with n_out columns\nNeuralNetworkClassifier Probabilistic AbstractMatrix{Continuous} or Table(Continuous) with n_in columns AbstractVector{<:Finite} with n_out classes\nNeuralNetworkBinaryClassifier Probabilistic AbstractMatrix{Continuous} or Table(Continuous) with n_in columns AbstractVector{<:Finite{2}} (but n_out = 1)\nImageClassifier Probabilistic AbstractVector(<:Image{W,H}) with n_in = (W, H) AbstractVector{<:Finite} with n_out classes","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"<details><summary><b>What exactly is a \"model\"?</b></summary>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"In MLJ a model is a mutable struct storing hyper-parameters for some learning algorithm indicated by the model name, and that's all. In particular, an MLJ model does not store learned parameters.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"warning: Difference in Definition\nIn Flux the term \"model\" has another meaning. However, as all Flux \"models\" used in MLJFLux are Flux.Chain objects, we call them chains, and restrict use of \"model\" to models in the MLJ sense.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"</details>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"<details open><summary><b>Are oberservations rows or columns?</b></summary>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"In MLJ the convention for two-dimensional data (tables and matrices) is rows=obervations. For matrices Flux has the opposite convention. If your data is a matrix with whose column index the observation index, then your optimal solution is to present the adjoint or transpose of your matrix to MLJFlux models. Otherwise, you can use the matrix as is, or transform one time with permutedims, and again present the adjoint or transpose as the optimal solution for MLJFlux training.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"</details>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Instructions for coercing common image formats into some AbstractVector{<:Image} are here.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"<details closed><summary><b>Fitting and warm restarts</b></summary>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"MLJ machines cache state enabling the \"warm restart\" of model training, as demonstrated in the incremental training example. In the case of MLJFlux models, fit!(mach) will use a warm restart if:","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"only model.epochs has changed since the last call; or\nonly model.epochs or model.optimiser have changed since the last call and model.optimiser_changes_trigger_retraining == false (the default) (the \"state\" part of the optimiser is ignored in this comparison). This allows one to dynamically modify learning rates, for example.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Here model=mach.model is the associated MLJ model.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"The warm restart feature makes it possible to externally control iteration. See, for example, Early Stopping with MLJFlux and Using MLJ to classifiy the MNIST image dataset.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"</details>","category":"page"},{"location":"interface/Summary/#Model-Hyperparameters.","page":"Summary","title":"Model Hyperparameters.","text":"","category":"section"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"All models share the following hyper-parameters. See individual model docstrings for a full list.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Hyper-parameter Description Default\nbuilder Default builder for models. MLJFlux.Linear(σ=Flux.relu) (regressors) or MLJFlux.Short(n_hidden=0, dropout=0.5, σ=Flux.σ) (classifiers)\noptimiser The optimiser to use for training. Optimiser.Adam()\nloss The loss function used for training. Flux.mse (regressors) and Flux.crossentropy (classifiers)\nn_epochs Number of epochs to train for. 10\nbatch_size The batch size for the data. 1\nlambda The regularization strength. Range = [0, ∞). 0\nalpha The L2/L1 mix of regularization. Range = [0, 1]. 0\nrng The random number generator (RNG) passed to builders, for weight initialization, for example. Can be any AbstractRNG or the seed (integer) for a Xoshirio that is reset on every cold restart of model (machine) training. GLOBAL_RNG\nacceleration Use CUDALibs() for training on GPU; default is CPU1(). CPU1()\noptimiser_changes_trigger_retraining True if fitting an associated machine should trigger retraining from scratch whenever the optimiser changes. false","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"The classifiers have an additional hyperparameter finaliser (default is Flux.softmax, or Flux.σ in the binary case) which is the operation applied to the unnormalized output of the final layer to obtain probabilities (outputs summing to one). It should return a vector of the same length as its input.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"note: Loss Functions\nCurrently, the loss function specified by loss=... is applied internally by Flux and needs to conform to the Flux API. You cannot, for example, supply one of MLJ's probabilistic loss functions, such as MLJ.cross_entropy to one of the classifier constructors.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"That said, you can only use MLJ loss functions or metrics in evaluation meta-algorithms (such as cross validation) and they will work even if the underlying model comes from MLJFlux.","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"<details closed><summary><b>More on accelerated training with GPUs</b></summary>","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"As in the table, when instantiating a model for training on a GPU, specify acceleration=CUDALibs(), as in","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"using MLJ\nImageClassifier = @load ImageClassifier\nmodel = ImageClassifier(epochs=10, acceleration=CUDALibs())\nmach = machine(model, X, y) |> fit!","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"In this example, the data X, y is copied onto the GPU under the hood on the call to fit! and cached for use in any warm restart (see above). The Flux chain used in training is always copied back to the CPU at then conclusion of fit!, and made available as fitted_params(mach).","category":"page"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"</details>","category":"page"},{"location":"interface/Summary/#Builders","page":"Summary","title":"Builders","text":"","category":"section"},{"location":"interface/Summary/","page":"Summary","title":"Summary","text":"Builder Description\nMLJFlux.MLP(hidden=(10,)) General multi-layer perceptron\nMLJFlux.Short(n_hidden=0, dropout=0.5, σ=sigmoid) Fully connected network with one hidden layer and dropout\nMLJFlux.Linear(σ=relu) Vanilla linear network with no hidden layers and activation function σ\nMLJFlux.@builder Macro for customized builders\n ","category":"page"},{"location":"common_workflows/incremental_training/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"common_workflows/incremental_training/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"common_workflows/incremental_training/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"common_workflows/incremental_training/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"interface/Classification/","page":"Classification","title":"Classification","text":"MLJFlux.NeuralNetworkClassifier\nMLJFlux.NeuralNetworkBinaryClassifier","category":"page"},{"location":"interface/Classification/#MLJFlux.NeuralNetworkClassifier","page":"Classification","title":"MLJFlux.NeuralNetworkClassifier","text":"NeuralNetworkClassifier\n\nA model type for constructing a neural network classifier, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nNeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n\nDo model = NeuralNetworkClassifier() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in NeuralNetworkClassifier(builder=...).\n\nNeuralNetworkClassifier is for training a data-dependent Flux.jl neural network for making probabilistic predictions of a Multiclass or OrderedFactor target, given a table of Continuous features. Users provide a recipe for constructing  the network, based on properties of the data that is encountered, by specifying  an appropriate builder. See MLJFlux documentation for more on builders.\n\nIn addition to features with Continuous scientific element type, this model supports categorical features in the input table. If present, such features are embedded into dense vectors by the use of an additional EntityEmbedder layer after the input, as described in Entity Embeddings of Categorical Variables by Cheng Guo, Felix Berkhahn arXiv, 2016.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX provides input features and is either: (i) a Matrix with Continuous element scitype (typically Float32); or (ii) a table of input features (eg, a DataFrame) whose columns have Continuous, Multiclass or OrderedFactor element scitype; check column scitypes with schema(X).  If any Multiclass or OrderedFactor features appear, the constructed network will use an EntityEmbedder layer to transform them into dense vectors. If X is a Matrix, it is assumed that columns correspond to features and rows corresponding to observations.\n\ny is the target, which can be any AbstractVector whose element scitype is Multiclass or OrderedFactor; check the scitype with scitype(y)\n\nTrain the machine with fit!(mach, rows=...).\n\nHyper-parameters\n\nbuilder=MLJFlux.Short(): An MLJFlux builder that constructs a neural network. Possible  builders include: MLJFlux.Linear, MLJFlux.Short, and MLJFlux.MLP. See  MLJFlux.jl documentation for examples of user-defined builders. See also finaliser  below.\noptimiser::Optimisers.Adam(): An Optimisers.jl optimiser. The optimiser performs the updating of the weights of the network. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.crossentropy: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a classification task, the most natural loss functions are:\nFlux.crossentropy: Standard multiclass classification loss, also known as the log loss.\nFlux.logitcrossentopy: Mathematically equal to crossentropy, but numerically more stable than finalising the outputs with softmax and then calculating crossentropy. You will need to specify finaliser=identity to remove MLJFlux's default softmax finaliser, and understand that the output of predict is then unnormalized (no longer probabilistic).\nFlux.tversky_loss: Used with imbalanced data to give more weight to false negatives.\nFlux.focal_loss: Used with highly imbalanced data. Weights harder examples more than easier examples.\nCurrently MLJ measures are not supported values of loss.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights.] Typically, batch size is between 8 and 512. Increassing batch size may accelerate training if acceleration=CUDALibs() and a GPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞). Note the history reports unpenalized losses.\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training. The default is Random.default_rng().\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\nfinaliser=Flux.softmax: The final activation function of the neural network (applied after the network defined by builder). Defaults to Flux.softmax.\nembedding_dims: a Dict whose keys are names of categorical features, given as symbols, and whose values are numbers representing the desired dimensionality of the entity embeddings of such features: an integer value of 7, say, sets the embedding dimensionality to 7; a float value of 0.5, say, sets the embedding dimensionality to ceil(0.5 * c), where c is the number of feature levels.  Unspecified feature dimensionality defaults to min(c - 1, 10).\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew, which should have the same scitype as X above. Predictions are probabilistic but uncalibrated.\npredict_mode(mach, Xnew): Return the modes of the probabilistic predictions returned above.\ntransform(mach, Xnew): Assuming Xnew has the same schema as X, transform the categorical features of Xnew into dense Continuous vectors using the MLJFlux.EntityEmbedder layer present in the network. Does nothing in case the model was trained on an input X that lacks categorical features.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers,  functions, and activations which make up the neural network. This includes  the final layer specified by finaliser (eg, softmax).\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalised if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we build a classification model using the Iris dataset. This is a very basic example, using a default builder and no standardization.  For a more advanced illustration, see NeuralNetworkRegressor or ImageClassifier, and examples in the MLJFlux.jl documentation.\n\nusing MLJ\nusing Flux\nimport RDatasets\nimport Optimisers\n\nFirst, we can load the data:\n\niris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng=123); # a vector and a table\nNeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\nclf = NeuralNetworkClassifier()\n\nNext, we can train the model:\n\nmach = machine(clf, X, y)\nfit!(mach)\n\nWe can train the model in an incremental fashion, altering the learning rate as we go, provided optimizer_changes_trigger_retraining is false (the default). Here, we also change the number of (total) iterations:\n\nclf.optimiser = Optimisers.Adam(clf.optimiser.eta * 2)\nclf.epochs = clf.epochs + 5\n\nfit!(mach, verbosity=2) # trains 5 more epochs\n\nWe can inspect the mean training loss using the cross_entropy function:\n\ntraining_loss = cross_entropy(predict(mach, X), y)\n\nAnd we can access the Flux chain (model) using fitted_params:\n\nchain = fitted_params(mach).chain\n\nFinally, we can see how the out-of-sample performance changes over time, using MLJ's learning_curve function:\n\nr = range(clf, :epochs, lower=1, upper=200, scale=:log10)\ncurve = learning_curve(clf, X, y,\n                     range=r,\n                     resampling=Holdout(fraction_train=0.7),\n                     measure=cross_entropy)\nusing Plots\nplot(curve.parameter_values,\n     curve.measurements,\n     xlab=curve.parameter_name,\n     xscale=curve.parameter_scale,\n     ylab = \"Cross Entropy\")\n\n\nSee also ImageClassifier, NeuralNetworkBinaryClassifier.\n\n\n\n\n\n","category":"type"},{"location":"interface/Classification/#MLJFlux.NeuralNetworkBinaryClassifier","page":"Classification","title":"MLJFlux.NeuralNetworkBinaryClassifier","text":"NeuralNetworkBinaryClassifier\n\nA model type for constructing a neural network binary classifier, based on MLJFlux.jl, and implementing the MLJ model interface.\n\nFrom MLJ, the type can be imported using\n\nNeuralNetworkBinaryClassifier = @load NeuralNetworkBinaryClassifier pkg=MLJFlux\n\nDo model = NeuralNetworkBinaryClassifier() to construct an instance with default hyper-parameters. Provide keyword arguments to override hyper-parameter defaults, as in NeuralNetworkBinaryClassifier(builder=...).\n\nNeuralNetworkBinaryClassifier is for training a data-dependent Flux.jl neural network for making probabilistic predictions of a binary (Multiclass{2} or OrderedFactor{2}) target, given a table of Continuous features. Users provide a recipe for constructing  the network, based on properties of the data that is encountered, by specifying  an appropriate builder. See MLJFlux documentation for more on builders.\n\nIn addition to features with Continuous scientific element type, this model supports categorical features in the input table. If present, such features are embedded into dense vectors by the use of an additional EntityEmbedder layer after the input, as described in Entity Embeddings of Categorical Variables by Cheng Guo, Felix Berkhahn arXiv, 2016.\n\nTraining data\n\nIn MLJ or MLJBase, bind an instance model to data with\n\nmach = machine(model, X, y)\n\nHere:\n\nX provides input features and is either: (i) a Matrix with Continuous element scitype (typically Float32); or (ii) a table of input features (eg, a DataFrame) whose columns have Continuous, Multiclass or OrderedFactor element scitype; check column scitypes with schema(X).  If any Multiclass or OrderedFactor features appear, the constructed network will use an EntityEmbedder layer to transform them into dense vectors. If X is a Matrix, it is assumed that columns correspond to features and rows corresponding to observations.\n\ny is the target, which can be any AbstractVector whose element scitype is Multiclass{2} or OrderedFactor{2}; check the scitype with scitype(y)\n\nTrain the machine with fit!(mach, rows=...).\n\nHyper-parameters\n\nbuilder=MLJFlux.Short(): An MLJFlux builder that constructs a neural network. Possible  builders include: MLJFlux.Linear, MLJFlux.Short, and MLJFlux.MLP. See  MLJFlux.jl documentation for examples of user-defined builders. See also finaliser  below.\noptimiser::Flux.Adam(): A Flux.Optimise optimiser. The optimiser performs the updating of the weights of the network. For further reference, see the Flux optimiser documentation. To choose a learning rate (the update rate of the optimizer), a good rule of thumb is to start out at 10e-3, and tune using powers of 10 between 1 and 1e-7.\nloss=Flux.binarycrossentropy: The loss function which the network will optimize. Should be a function which can be called in the form loss(yhat, y).  Possible loss functions are listed in the Flux loss function documentation. For a classification task, the most natural loss functions are:\nFlux.binarycrossentropy: Standard binary classification loss, also known as the log loss.\nFlux.logitbinarycrossentropy: Mathematically equal to crossentropy, but numerically more stable than finalising the outputs with σ and then calculating crossentropy. You will need to specify finaliser=identity to remove MLJFlux's default sigmoid finaliser, and understand that the output of predict is then unnormalized (no longer probabilistic).\nFlux.tversky_loss: Used with imbalanced data to give more weight to false negatives.\nFlux.binary_focal_loss: Used with highly imbalanced data. Weights harder examples more than easier examples.\nCurrently MLJ measures are not supported values of loss.\nepochs::Int=10: The duration of training, in epochs. Typically, one epoch represents one pass through the complete the training dataset.\nbatch_size::int=1: the batch size to be used for training, representing the number of samples per update of the network weights. Typically, batch size is between 8 and 512. Increassing batch size may accelerate training if acceleration=CUDALibs() and a GPU is available.\nlambda::Float64=0: The strength of the weight regularization penalty. Can be any value in the range [0, ∞).\nalpha::Float64=0: The L2/L1 mix of regularization, in the range [0, 1]. A value of 0 represents L2 regularization, and a value of 1 represents L1 regularization.\nrng::Union{AbstractRNG, Int64}: The random number generator or seed used during training.\noptimizer_changes_trigger_retraining::Bool=false: Defines what happens when re-fitting a machine if the associated optimiser has changed. If true, the associated machine will retrain from scratch on fit! call, otherwise it will not.\nacceleration::AbstractResource=CPU1(): Defines on what hardware training is done. For Training on GPU, use CUDALibs().\nfinaliser=Flux.σ: The final activation function of the neural network (applied after the network defined by builder). Defaults to Flux.σ.\nembedding_dims: a Dict whose keys are names of categorical features, given as symbols, and whose values are numbers representing the desired dimensionality of the entity embeddings of such features: an integer value of 7, say, sets the embedding dimensionality to 7; a float value of 0.5, say, sets the embedding dimensionality to ceil(0.5 * c), where c is the number of feature levels.  Unspecified feature dimensionality defaults to min(c - 1, 10).\n\nOperations\n\npredict(mach, Xnew): return predictions of the target given new features Xnew, which should have the same scitype as X above. Predictions are probabilistic but uncalibrated.\npredict_mode(mach, Xnew): Return the modes of the probabilistic predictions returned above.\ntransform(mach, Xnew): Assuming Xnew has the same schema as X, transform the categorical features of Xnew into dense Continuous vectors using the MLJFlux.EntityEmbedder layer present in the network. Does nothing in case the model was trained on an input X that lacks categorical features.\n\nFitted parameters\n\nThe fields of fitted_params(mach) are:\n\nchain: The trained \"chain\" (Flux.jl model), namely the series of layers,  functions, and activations which make up the neural network. This includes  the final layer specified by finaliser (eg, softmax).\n\nReport\n\nThe fields of report(mach) are:\n\ntraining_losses: A vector of training losses (penalised if lambda != 0) in  historical order, of length epochs + 1.  The first element is the pre-training loss.\n\nExamples\n\nIn this example we build a classification model using the Iris dataset. This is a very basic example, using a default builder and no standardization.  For a more advanced illustration, see NeuralNetworkRegressor or ImageClassifier, and examples in the MLJFlux.jl documentation.\n\nusing MLJ, Flux\nimport Optimisers\nimport RDatasets\n\nFirst, we can load the data:\n\nmtcars = RDatasets.dataset(\"datasets\", \"mtcars\");\ny, X = unpack(mtcars, ==(:VS), in([:MPG, :Cyl, :Disp, :HP, :WT, :QSec]));\n\nNote that y is a vector and X a table.\n\ny = categorical(y) # classifier takes catogorical input\nX_f32 = Float32.(X) # To match floating point type of the neural network layers\nNeuralNetworkBinaryClassifier = @load NeuralNetworkBinaryClassifier pkg=MLJFlux\nbclf = NeuralNetworkBinaryClassifier()\n\nNext, we can train the model:\n\nmach = machine(bclf, X_f32, y)\nfit!(mach)\n\nWe can train the model in an incremental fashion, altering the learning rate as we go, provided optimizer_changes_trigger_retraining is false (the default). Here, we also change the number of (total) iterations:\n\njulia> bclf.optimiser\nAdam(0.001, (0.9, 0.999), 1.0e-8)\n\nbclf.optimiser = Optimisers.Adam(eta = bclf.optimiser.eta * 2)\nbclf.epochs = bclf.epochs + 5\n\nfit!(mach, verbosity=2) # trains 5 more epochs\n\nWe can inspect the mean training loss using the cross_entropy function:\n\ntraining_loss = cross_entropy(predict(mach, X_f32), y)\n\nAnd we can access the Flux chain (model) using fitted_params:\n\nchain = fitted_params(mach).chain\n\nFinally, we can see how the out-of-sample performance changes over time, using MLJ's learning_curve function:\n\nr = range(bclf, :epochs, lower=1, upper=200, scale=:log10)\ncurve = learning_curve(\n    bclf,\n    X_f32,\n    y,\n    range=r,\n    resampling=Holdout(fraction_train=0.7),\n    measure=cross_entropy,\n)\nusing Plots\nplot(\n   curve.parameter_values,\n   curve.measurements,\n   xlab=curve.parameter_name,\n   xscale=curve.parameter_scale,\n   ylab = \"Cross Entropy\",\n)\n\n\nSee also ImageClassifier.\n\n\n\n\n\n","category":"type"},{"location":"common_workflows/architecture_search/README/#Contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"common_workflows/architecture_search/README/","page":"Contents","title":"Contents","text":"file description\nnotebook.ipynb Juptyer notebook (executed)\nnotebook.unexecuted.ipynb Jupyter notebook (unexecuted)\nnotebook.md static markdown (included in MLJFlux.jl docs)\nnotebook.jl executable Julia script annotated with comments\ngenerate.jl maintainers only: execute to generate first 3 from 4th","category":"page"},{"location":"common_workflows/architecture_search/README/#Important","page":"Contents","title":"Important","text":"","category":"section"},{"location":"common_workflows/architecture_search/README/","page":"Contents","title":"Contents","text":"Scripts or notebooks in this folder cannot be reliably executed without the accompanying Manifest.toml and Project.toml files.","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"EditURL = \"notebook.jl\"","category":"page"},{"location":"common_workflows/live_training/notebook/#Live-Training-with-MLJFlux","page":"Live Training","title":"Live Training with MLJFlux","text":"","category":"section"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"This demonstration is available as a Jupyter notebook or julia script here.","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"Julia version is assumed to be 1.10.*","category":"page"},{"location":"common_workflows/live_training/notebook/#Basic-Imports","page":"Live Training","title":"Basic Imports","text":"","category":"section"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"using MLJ\nusing Flux\nimport RDatasets\nimport Optimisers","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"using Plots","category":"page"},{"location":"common_workflows/live_training/notebook/#Loading-and-Splitting-the-Data","page":"Live Training","title":"Loading and Splitting the Data","text":"","category":"section"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"iris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), rng=123);\nX = Float32.(X);      # To be compatible with type of network network parameters\nnothing #hide","category":"page"},{"location":"common_workflows/live_training/notebook/#Instantiating-the-model","page":"Live Training","title":"Instantiating the model","text":"","category":"section"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"Now let's construct our model. This follows a similar setup to the one followed in the Quick Start.","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"NeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=MLJFlux\n\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Optimisers.Adam(0.01),\n    batch_size=8,\n    epochs=50,\n    rng=42,\n)","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"Now let's wrap this in an iterated model. We will use a callback that makes a plot for validation losses each iteration.","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"stop_conditions = [\n    Step(1),            # Repeatedly train for one iteration\n    NumberLimit(100),   # Don't train for more than 100 iterations\n]\n\nvalidation_losses =  []\ngr(reuse=true)                  # use the same window for plots\nfunction plot_loss(loss)\n    push!(validation_losses, loss)\n    display(plot(validation_losses, label=\"validation loss\", xlim=(1, 100)))\n    sleep(.01)  # to catch up with the plots while they are being generated\nend\n\ncallbacks = [ WithLossDo(plot_loss),]\n\niterated_model = IteratedModel(\n    model=clf,\n    resampling=Holdout(),\n    measures=log_loss,\n    iteration_parameter=:(epochs),\n    controls=vcat(stop_conditions, callbacks),\n    retrain=true,\n)","category":"page"},{"location":"common_workflows/live_training/notebook/#Live-Training","page":"Live Training","title":"Live Training","text":"","category":"section"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"Simply fitting the model is all we need","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"mach = machine(iterated_model, X, y)\nfit!(mach, force=true)","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"","category":"page"},{"location":"common_workflows/live_training/notebook/","page":"Live Training","title":"Live Training","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#MLJFlux.jl","page":"Introduction","title":"MLJFlux.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A Julia package integrating deep learning Flux models with MLJ.","category":"page"},{"location":"#Objectives","page":"Introduction","title":"Objectives","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Provide a user-friendly and high-level interface to fundamental Flux deep learning models while still being extensible by supporting custom models written with Flux\nMake building deep learning models more convenient to users already familiar with the MLJ workflow\nMake it easier to apply machine learning techniques provided by MLJ, including: out-of-sample performance evaluation, hyper-parameter optimization, iteration control, and more, to deep learning models","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: MLJFlux Scope\nMLJFlux support is focused on fundamental deep learning models for common supervised learning tasks. Sophisticated architectures and approaches, such as online learning, reinforcement learning, and adversarial networks, are currently outside its scope. Also, MLJFlux is limited to tasks where all (batches of) training data  fits into memory.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.activate(\"my_environment\", shared=true)\nPkg.add([\"MLJ\", \"MLJFlux\", \"Optimisers\", \"Flux\"])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You only need Flux if you need to build a custom architecture, or experiment with different loss or activation functions. Since MLJFlux 0.5, you must use optimisers from Optimisers.jl, as native Flux.jl optimisers are no longer supported. ","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"For the following demo, you will need to additionally run Pkg.add(\"RDatasets\").","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using MLJ, Flux, MLJFlux\nimport RDatasets\nimport Optimisers\n\n# 1. Load Data\niris = RDatasets.dataset(\"datasets\", \"iris\");\ny, X = unpack(iris, ==(:Species), colname -> true, rng=123);\n\n# 2. Load and instantiate model\nNeuralNetworkClassifier = @load NeuralNetworkClassifier pkg=\"MLJFlux\"\nclf = NeuralNetworkClassifier(\n    builder=MLJFlux.MLP(; hidden=(5,4), σ=Flux.relu),\n    optimiser=Optimisers.Adam(0.01),\n    batch_size=8,\n    epochs=100, \n    acceleration=CUDALibs()         # For GPU support\n    )\n\n# 3. Wrap it in a machine \nmach = machine(clf, X, y)\n\n# 4. Evaluate the model\ncv=CV(nfolds=5)\nevaluate!(mach, resampling=cv, measure=accuracy) ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As you can see we are able to use MLJ meta-functionality (i.e., cross validation) with a Flux deep learning model. All arguments provided have defaults.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Notice that we are also able to define the neural network in a high-level fashion by only specifying the number of neurons in each hidden layer and the activation function. Meanwhile, MLJFlux is able to infer the input and output layer as well as use a suitable default for the loss function and output activation given the classification task. Notice as well that we did not need to manually implement a training or prediction loop.","category":"page"},{"location":"#Basic-idea:-\"builders\"-for-data-dependent-architecture","page":"Introduction","title":"Basic idea: \"builders\" for data-dependent architecture","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"As in the example above, any MLJFlux model has a builder hyperparameter, an object encoding instructions for creating a neural network given the data that the model eventually sees (e.g., the number of classes in a classification problem). While each MLJ model has a simple default builder, users may need to define custom builders to get optimal results (see Defining Custom Builders and this will require familiarity with the Flux API for defining a neural network chain.","category":"page"},{"location":"#Flux-or-MLJFlux?","page":"Introduction","title":"Flux or MLJFlux?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Flux is a deep learning framework in Julia that comes with everything you need to build deep learning models (i.e., GPU support, automatic differentiation, layers, activations, losses, optimizers, etc.). MLJFlux wraps models built with Flux which provides a more high-level interface for building and training such models. More importantly, it empowers Flux models by extending their support to many common machine learning workflows that are possible via MLJ such as:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Estimating performance of your model using a holdout set or other resampling strategy (e.g., cross-validation) as measured by one or more metrics (e.g., loss functions) that may not have been used in training\nOptimizing hyper-parameters such as a regularization parameter (e.g., dropout) or a width/height/nchannnels of convolution layer\nCompose with other models such as introducing data pre-processing steps (e.g., missing data imputation) into a pipeline. It might make sense to include non-deep learning models in this pipeline. Other kinds of model composition could include blending predictions of a deep learner with some other kind of model (as in “model stacking”). Models composed with MLJ can be also tuned as a single unit.\nControlling iteration by adding an early stopping criterion based on an out-of-sample estimate of the loss, dynamically changing the learning rate (eg, cyclic learning rates), periodically save snapshots of the model, generate live plots of sample weights to judge training progress (as in tensor board)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Comparing your model with a non-deep learning models","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A comparable project, FastAI/FluxTraining, also provides a high-level interface for interacting with Flux models and supports a set of features that may overlap with (but not include all of) those supported by MLJFlux.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Many of the features mentioned above are showcased in the workflow examples that you can access from the sidebar.","category":"page"},{"location":"interface/Custom Builders/#Defining-Custom-Builders","page":"Custom Builders","title":"Defining Custom Builders","text":"","category":"section"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"Following is an example defining a new builder for creating a simple fully-connected neural network with two hidden layers, with n1 nodes in the first hidden layer, and n2 nodes in the second, for use in any of the first three models in Table 1. The definition includes one mutable struct and one method:","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"mutable struct MyBuilder <: MLJFlux.Builder\n\tn1 :: Int\n\tn2 :: Int\nend\n\nfunction MLJFlux.build(nn::MyBuilder, rng, n_in, n_out)\n\tinit = Flux.glorot_uniform(rng)\n        return Chain(\n            Dense(n_in, nn.n1, init=init),\n            Dense(nn.n1, nn.n2, init=init),\n            Dense(nn.n2, n_out, init=init),\n            )\nend","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"Note here that n_in and n_out depend on the size of the data (see Table 1).","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"For a concrete image classification example, see Using MLJ to classifiy the MNIST image dataset.","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"More generally, defining a new builder means defining a new struct sub-typing MLJFlux.Builder and defining a new MLJFlux.build method with one of these signatures:","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"MLJFlux.build(builder::MyBuilder, rng, n_in, n_out)\nMLJFlux.build(builder::MyBuilder, rng, n_in, n_out, n_channels) # for use with `ImageClassifier`","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"This method must return a Flux.Chain instance, chain, subject to the following conditions:","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"chain(x) must make sense:\nfor any x <: Array{<:AbstractFloat, 2} of size (n_in, batch_size) where batch_size is any integer (for all models except ImageClassifier); or\nfor any x <: Array{<:Float32, 4} of size (W, H, n_channels, batch_size), where (W, H) = n_in, n_channels is 1 or 3, and batch_size is any integer (for use with ImageClassifier)\nThe object returned by chain(x) must be an AbstractFloat vector of length n_out.","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"Alternatively, use MLJFlux.@builder(neural_net) to automatically create a builder for any valid Flux chain expression neural_net, where the symbols n_in, n_out, n_channels and rng can appear literally, with the interpretations explained above. For example,","category":"page"},{"location":"interface/Custom Builders/","page":"Custom Builders","title":"Custom Builders","text":"builder = MLJFlux.@builder Chain(Dense(n_in, 128), Dense(128, n_out, tanh))","category":"page"}]
}
